#include "parser.hpp"
#include <iostream>

 leaf::parsing::instance::resettable::resettable(instance& ref): m_ref(ref)
{
    m_contents = ref.m_contents;
    m_file = ref.m_file;
    m_line = ref.m_line;
    m_column = ref.m_column;
    m_offset = ref.m_offset;
}
void leaf::parsing::instance::resettable::reset()
{
    m_ref.m_contents   = m_contents;
    m_ref.m_file       = m_file;
    m_ref.m_line       = m_line;
    m_ref.m_column     = m_column;
    m_ref.m_offset     = m_offset;
}
bool leaf::parsing::instance::next()
{
    if (m_contents.length() > m_offset)
    {
        char c = m_contents[m_offset];
        switch (c)
        {
            case '\r':
            case '\t':
            case ' ':
            default: m_column++; m_offset++; break;
            case '\n': m_line++; m_column = 1; m_offset++; break;
        }
        return true;
    }
    else
    {
        return false;
    }
}
char leaf::parsing::instance::current()
{
    if (m_contents.length() > m_offset)
    {
        return m_contents[m_offset];
    }
    else
    {
        return '\0';
    }
}
std::optional<size_t> leaf::parsing::instance::token_integer_binary(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "0b";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count4 = 0;
    while (current() != '\0')
    {
        if (('0' <= current() && current() <= '9'))
        {
            count4++;
            next();
            continue;
        }
        std::optional<size_t> res5 = token_underscore(depth + 1);
        if (res5.has_value())
        {
            count4++;
            for (size_t i = 0; i < res5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count4 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable1 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable1;
}
std::optional<size_t> leaf::parsing::instance::token_integer_hex(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "0x";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count4 = 0;
    while (current() != '\0')
    {
        if (('0' <= current() && current() <= '9'))
        {
            count4++;
            next();
            continue;
        }
        std::optional<size_t> res5 = token_underscore(depth + 1);
        if (res5.has_value())
        {
            count4++;
            for (size_t i = 0; i < res5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count4 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable2 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable2;
}
std::optional<size_t> leaf::parsing::instance::token_integer_unsigned(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0')
    {
        if (('0' <= current() && current() <= '9'))
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable3 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable3;
}
std::optional<size_t> leaf::parsing::instance::token_integer_signed_negative(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '-')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count3 = 0;
    while (current() != '\0')
    {
        if (('0' <= current() && current() <= '9'))
        {
            count3++;
            next();
            continue;
        }
        break;
    }
    if (count3 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable4 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable4;
}
std::optional<size_t> leaf::parsing::instance::token_integer_signed_positive(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '+')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count3 = 0;
    while (current() != '\0')
    {
        if (('0' <= current() && current() <= '9'))
        {
            count3++;
            next();
            continue;
        }
        break;
    }
    if (count3 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable5 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable5;
}
std::optional<size_t> leaf::parsing::instance::token_integer(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        std::optional<size_t> res3 = token_integer_signed_positive(depth + 1);
        if (res3.has_value())
        {
            count2++;
            for (size_t i = 0; i < res3; i++)
            {
                next();
            }
            continue;
        }
        std::optional<size_t> res4 = token_integer_signed_negative(depth + 1);
        if (res4.has_value())
        {
            count2++;
            for (size_t i = 0; i < res4; i++)
            {
                next();
            }
            continue;
        }
        std::optional<size_t> res5 = token_integer_unsigned(depth + 1);
        if (res5.has_value())
        {
            count2++;
            for (size_t i = 0; i < res5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable6 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable6;
}
std::optional<size_t> leaf::parsing::instance::token_scalar(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        std::optional<size_t> res3 = token_integer(depth + 1);
        if (res3.has_value())
        {
            count2++;
            for (size_t i = 0; i < res3; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count4 = 0;
    while (current() != '\0' && count4 < 1)
    {
        if (current() == '.')
        {
            count4++;
            next();
            continue;
        }
        break;
    }
    if (count4 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count5 = 0;
    while (current() != '\0' && count5 < 1)
    {
        std::optional<size_t> res6 = token_integer(depth + 1);
        if (res6.has_value())
        {
            count5++;
            for (size_t i = 0; i < res6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count5 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable7 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable7;
}
std::optional<size_t> leaf::parsing::instance::token_slash(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '/')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable8 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable8;
}
std::optional<size_t> leaf::parsing::instance::token_star(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '*')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable9 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable9;
}
std::optional<size_t> leaf::parsing::instance::token_plus(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '+')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable10 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable10;
}
std::optional<size_t> leaf::parsing::instance::token_minus(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '-')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable11 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable11;
}
std::optional<size_t> leaf::parsing::instance::token_underscore(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '_')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable12 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable12;
}
std::optional<size_t> leaf::parsing::instance::token_true_(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "true";
        if (m_contents.length() - m_offset >= 4 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 4, str3, str3 + 4))
        {
            count2++;
            for (size_t i = 0; i < 4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable13 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable13;
}
std::optional<size_t> leaf::parsing::instance::token_false_(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "false";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable14 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable14;
}
std::optional<size_t> leaf::parsing::instance::token_ident(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (('a' <= current() && current() <= 'z'))
        {
            count2++;
            next();
            continue;
        }
        else if (('A' <= current() && current() <= 'Z'))
        {
            count2++;
            next();
            continue;
        }
        std::optional<size_t> res3 = token_underscore(depth + 1);
        if (res3.has_value())
        {
            count2++;
            for (size_t i = 0; i < res3; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count4 = 0;
    while (current() != '\0')
    {
        if (('a' <= current() && current() <= 'z'))
        {
            count4++;
            next();
            continue;
        }
        else if (('A' <= current() && current() <= 'Z'))
        {
            count4++;
            next();
            continue;
        }
        else if (('0' <= current() && current() <= '9'))
        {
            count4++;
            next();
            continue;
        }
        std::optional<size_t> res5 = token_underscore(depth + 1);
        if (res5.has_value())
        {
            count4++;
            for (size_t i = 0; i < res5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    size_t count6 = 1;
    size_t local_offset7 = 0;
    while (current() != '\0' && count6 > 0)
    {
        if (m_offset >= 1 && m_contents[m_offset - 1] == '-')
        {
            break;
        }
        count6--;
    }
    if (count6 >= 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable15 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable15;
}
std::optional<size_t> leaf::parsing::instance::token_string_formatable_start(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '$')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count3 = 0;
    while (current() != '\0' && count3 < 1)
    {
        if (current() == '\"')
        {
            count3++;
            next();
            continue;
        }
        break;
    }
    if (count3 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count4 = 0;
    while (current() != '\0')
    {
        if (current() != '{')
        {
            count4++;
            next();
            continue;
        }
        break;
    }
    size_t count5 = 0;
    while (current() != '\0' && count5 < 1)
    {
        if (current() == '{')
        {
            count5++;
            next();
            continue;
        }
        break;
    }
    if (count5 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable16 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable16;
}
std::optional<size_t> leaf::parsing::instance::token_string_formatable_fake(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '$')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count3 = 0;
    while (current() != '\0' && count3 < 1)
    {
        if (current() == '\"')
        {
            count3++;
            next();
            continue;
        }
        break;
    }
    if (count3 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count4 = 0;
    while (current() != '\0')
    {
        std::optional<size_t> res5 = token_string_unescaped_ending(depth + 1);
        if (res5.has_value())
        {
            count4++;
            for (size_t i = 0; i < res5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    size_t count6 = 0;
    while (current() != '\0' && count6 < 1)
    {
        if (current() == '\"')
        {
            count6++;
            next();
            continue;
        }
        break;
    }
    if (count6 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable17 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable17;
}
std::optional<size_t> leaf::parsing::instance::token_string_formatable_continuation(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '}')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count3 = 0;
    while (current() != '\0')
    {
        if (current() != '{')
        {
            count3++;
            next();
            continue;
        }
        break;
    }
    size_t count4 = 0;
    while (current() != '\0' && count4 < 1)
    {
        if (current() == '{')
        {
            count4++;
            next();
            continue;
        }
        break;
    }
    if (count4 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable18 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable18;
}
std::optional<size_t> leaf::parsing::instance::token_string_formatable_end(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '}')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count3 = 0;
    while (current() != '\0')
    {
        std::optional<size_t> res4 = token_string_unescaped_ending(depth + 1);
        if (res4.has_value())
        {
            count3++;
            for (size_t i = 0; i < res4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    size_t count5 = 0;
    while (current() != '\0' && count5 < 1)
    {
        if (current() == '\"')
        {
            count5++;
            next();
            continue;
        }
        break;
    }
    if (count5 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable19 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable19;
}
std::optional<size_t> leaf::parsing::instance::token_string_unescaped_ending(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 1;
    size_t local_offset3 = 0;
    while (current() != '\0' && count2 > 0)
    {
        if (m_offset >= 1 && m_contents[m_offset - 1] == '\')
        {
            break;
        }
        count2--;
    }
    if (count2 >= 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count4 = 0;
    while (current() != '\0' && count4 < 1)
    {
        if (current() == '\"')
        {
            count4++;
            next();
            continue;
        }
        break;
    }
    if (count4 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable20 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable20;
}
std::optional<size_t> leaf::parsing::instance::token_string(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '\"')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count3 = 0;
    while (current() != '\0')
    {
        std::optional<size_t> res4 = token_string_unescaped_ending(depth + 1);
        if (res4.has_value())
        {
            count3++;
            for (size_t i = 0; i < res4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    size_t count5 = 0;
    while (current() != '\0' && count5 < 1)
    {
        if (current() == '\"')
        {
            count5++;
            next();
            continue;
        }
        break;
    }
    if (count5 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable21 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable21;
}
std::optional<size_t> leaf::parsing::instance::token_char_unescaped_ending(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 1;
    size_t local_offset3 = 0;
    while (current() != '\0' && count2 > 0)
    {
        if (m_offset >= 1 && m_contents[m_offset - 1] == '\')
        {
            break;
        }
        count2--;
    }
    if (count2 >= 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count4 = 0;
    while (current() != '\0' && count4 < 1)
    {
        if (current() == '\'')
        {
            count4++;
            next();
            continue;
        }
        break;
    }
    if (count4 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable22 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable22;
}
std::optional<size_t> leaf::parsing::instance::token_char_(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '\'')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    size_t count3 = 0;
    while (current() != '\0')
    {
        std::optional<size_t> res4 = token_char_unescaped_ending(depth + 1);
        if (res4.has_value())
        {
            count3++;
            for (size_t i = 0; i < res4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    size_t count5 = 0;
    while (current() != '\0' && count5 < 1)
    {
        if (current() == '\'')
        {
            count5++;
            next();
            continue;
        }
        break;
    }
    if (count5 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable23 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable23;
}
std::optional<size_t> leaf::parsing::instance::token__colon(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == ':')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable24 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable24;
}
std::optional<size_t> leaf::parsing::instance::token__comma(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == ',')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable25 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable25;
}
std::optional<size_t> leaf::parsing::instance::token__round_bracket_open(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '(')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable26 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable26;
}
std::optional<size_t> leaf::parsing::instance::token__round_bracket_close(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == ')')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable27 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable27;
}
std::optional<size_t> leaf::parsing::instance::token__square_bracket_open(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '[')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable28 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable28;
}
std::optional<size_t> leaf::parsing::instance::token__square_bracket_close(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == ']')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable29 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable29;
}
std::optional<size_t> leaf::parsing::instance::token__contract(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "contract";
        if (m_contents.length() - m_offset >= 8 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 8, str3, str3 + 8))
        {
            count2++;
            for (size_t i = 0; i < 8; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable30 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable30;
}
std::optional<size_t> leaf::parsing::instance::token__curly_bracket_open(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '{')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable31 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable31;
}
std::optional<size_t> leaf::parsing::instance::token__curly_bracket_close(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '}')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable32 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable32;
}
std::optional<size_t> leaf::parsing::instance::token__semicolon(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == ';')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable33 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable33;
}
std::optional<size_t> leaf::parsing::instance::token__get(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "get";
        if (m_contents.length() - m_offset >= 3 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 3, str3, str3 + 3))
        {
            count2++;
            for (size_t i = 0; i < 3; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable34 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable34;
}
std::optional<size_t> leaf::parsing::instance::token__set(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "set";
        if (m_contents.length() - m_offset >= 3 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 3, str3, str3 + 3))
        {
            count2++;
            for (size_t i = 0; i < 3; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable35 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable35;
}
std::optional<size_t> leaf::parsing::instance::token__operator(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "operator";
        if (m_contents.length() - m_offset >= 8 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 8, str3, str3 + 8))
        {
            count2++;
            for (size_t i = 0; i < 8; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable36 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable36;
}
std::optional<size_t> leaf::parsing::instance::token__less_then_less_then_less_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "<<<";
        if (m_contents.length() - m_offset >= 3 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 3, str3, str3 + 3))
        {
            count2++;
            for (size_t i = 0; i < 3; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable37 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable37;
}
std::optional<size_t> leaf::parsing::instance::token__less_then_less_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "<<";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable38 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable38;
}
std::optional<size_t> leaf::parsing::instance::token__less_then_equal(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "<=";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable39 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable39;
}
std::optional<size_t> leaf::parsing::instance::token__less_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '<')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable40 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable40;
}
std::optional<size_t> leaf::parsing::instance::token__greater_then_greater_then_greater_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = ">>>";
        if (m_contents.length() - m_offset >= 3 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 3, str3, str3 + 3))
        {
            count2++;
            for (size_t i = 0; i < 3; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable41 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable41;
}
std::optional<size_t> leaf::parsing::instance::token__greater_then_greater_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = ">>";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable42 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable42;
}
std::optional<size_t> leaf::parsing::instance::token__greater_then_equal(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = ">=";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable43 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable43;
}
std::optional<size_t> leaf::parsing::instance::token__greater_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '>')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable44 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable44;
}
std::optional<size_t> leaf::parsing::instance::token__vertical_bar_vertical_bar(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "||";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable45 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable45;
}
std::optional<size_t> leaf::parsing::instance::token__vertical_bar(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '|')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable46 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable46;
}
std::optional<size_t> leaf::parsing::instance::token__ampersand_ampersand(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "&&";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable47 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable47;
}
std::optional<size_t> leaf::parsing::instance::token__ampersand(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '&')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable48 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable48;
}
std::optional<size_t> leaf::parsing::instance::token__equal_equal_equal(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "===";
        if (m_contents.length() - m_offset >= 3 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 3, str3, str3 + 3))
        {
            count2++;
            for (size_t i = 0; i < 3; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable49 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable49;
}
std::optional<size_t> leaf::parsing::instance::token__equal_equal(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "==";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable50 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable50;
}
std::optional<size_t> leaf::parsing::instance::token__exclamation_equal(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "!=";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable51 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable51;
}
std::optional<size_t> leaf::parsing::instance::token__circumflex(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '^')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable52 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable52;
}
std::optional<size_t> leaf::parsing::instance::token__exclamation(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '!')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable53 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable53;
}
std::optional<size_t> leaf::parsing::instance::token__tilde(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '~')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable54 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable54;
}
std::optional<size_t> leaf::parsing::instance::token__dot(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '.')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable55 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable55;
}
std::optional<size_t> leaf::parsing::instance::token__minus_greater_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "->";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable56 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable56;
}
std::optional<size_t> leaf::parsing::instance::token__equal_greater_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "=>";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable57 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable57;
}
std::optional<size_t> leaf::parsing::instance::token__while(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "while";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable58 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable58;
}
std::optional<size_t> leaf::parsing::instance::token__if(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "if";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable59 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable59;
}
std::optional<size_t> leaf::parsing::instance::token__else(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "else";
        if (m_contents.length() - m_offset >= 4 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 4, str3, str3 + 4))
        {
            count2++;
            for (size_t i = 0; i < 4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable60 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable60;
}
std::optional<size_t> leaf::parsing::instance::token__for(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "for";
        if (m_contents.length() - m_offset >= 3 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 3, str3, str3 + 3))
        {
            count2++;
            for (size_t i = 0; i < 3; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable61 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable61;
}
std::optional<size_t> leaf::parsing::instance::token__case(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "case";
        if (m_contents.length() - m_offset >= 4 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 4, str3, str3 + 4))
        {
            count2++;
            for (size_t i = 0; i < 4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable62 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable62;
}
std::optional<size_t> leaf::parsing::instance::token__switch(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "switch";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable63 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable63;
}
std::optional<size_t> leaf::parsing::instance::token__default(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "default";
        if (m_contents.length() - m_offset >= 7 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 7, str3, str3 + 7))
        {
            count2++;
            for (size_t i = 0; i < 7; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable64 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable64;
}
std::optional<size_t> leaf::parsing::instance::token__eol(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '\n')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable65 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable65;
}
std::optional<size_t> leaf::parsing::instance::token__assembly(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "assembly";
        if (m_contents.length() - m_offset >= 8 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 8, str3, str3 + 8))
        {
            count2++;
            for (size_t i = 0; i < 8; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable66 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable66;
}
std::optional<size_t> leaf::parsing::instance::token__copy(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "copy";
        if (m_contents.length() - m_offset >= 4 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 4, str3, str3 + 4))
        {
            count2++;
            for (size_t i = 0; i < 4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable67 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable67;
}
std::optional<size_t> leaf::parsing::instance::token__tilde_equal(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "~=";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable68 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable68;
}
std::optional<size_t> leaf::parsing::instance::token__equal(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '=')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable69 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable69;
}
std::optional<size_t> leaf::parsing::instance::token__public(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "public";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable70 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable70;
}
std::optional<size_t> leaf::parsing::instance::token__local(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "local";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable71 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable71;
}
std::optional<size_t> leaf::parsing::instance::token__derived(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "derived";
        if (m_contents.length() - m_offset >= 7 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 7, str3, str3 + 7))
        {
            count2++;
            for (size_t i = 0; i < 7; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable72 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable72;
}
std::optional<size_t> leaf::parsing::instance::token__private(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "private";
        if (m_contents.length() - m_offset >= 7 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 7, str3, str3 + 7))
        {
            count2++;
            for (size_t i = 0; i < 7; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable73 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable73;
}
std::optional<size_t> leaf::parsing::instance::token__namespace(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "namespace";
        if (m_contents.length() - m_offset >= 9 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 9, str3, str3 + 9))
        {
            count2++;
            for (size_t i = 0; i < 9; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable74 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable74;
}
std::optional<size_t> leaf::parsing::instance::token__class(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "class";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable75 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable75;
}
std::optional<size_t> leaf::parsing::instance::token__sealed(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "sealed";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable76 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable76;
}
std::optional<size_t> leaf::parsing::instance::token__virtual(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "virtual";
        if (m_contents.length() - m_offset >= 7 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 7, str3, str3 + 7))
        {
            count2++;
            for (size_t i = 0; i < 7; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable77 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable77;
}
std::optional<size_t> leaf::parsing::instance::token__unbound(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "unbound";
        if (m_contents.length() - m_offset >= 7 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 7, str3, str3 + 7))
        {
            count2++;
            for (size_t i = 0; i < 7; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable78 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable78;
}
std::optional<size_t> leaf::parsing::instance::token__inline(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "inline";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable79 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable79;
}
std::optional<size_t> leaf::parsing::instance::token__delete(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "delete";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable80 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable80;
}
std::optional<size_t> leaf::parsing::instance::token__conversion(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "conversion";
        if (m_contents.length() - m_offset >= 10 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 10, str3, str3 + 10))
        {
            count2++;
            for (size_t i = 0; i < 10; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable81 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable81;
}
std::optional<size_t> leaf::parsing::instance::token__const(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "const";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable82 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable82;
}
std::optional<size_t> leaf::parsing::instance::token__using(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "using";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable83 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable83;
}
std::optional<size_t> leaf::parsing::instance::token__alias(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "alias";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable84 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable84;
}
std::optional<size_t> leaf::parsing::instance::token__free(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "free";
        if (m_contents.length() - m_offset >= 4 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 4, str3, str3 + 4))
        {
            count2++;
            for (size_t i = 0; i < 4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable85 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable85;
}
std::optional<size_t> leaf::parsing::instance::token__alloc(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "alloc";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable86 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable86;
}
std::optional<size_t> leaf::parsing::instance::token__stack(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "stack";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable87 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable87;
}
std::optional<size_t> leaf::parsing::instance::token__heap(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "heap";
        if (m_contents.length() - m_offset >= 4 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 4, str3, str3 + 4))
        {
            count2++;
            for (size_t i = 0; i < 4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable88 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable88;
}
std::optional<size_t> leaf::parsing::instance::token__typeof(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "typeof";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable89 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable89;
}
std::optional<size_t> leaf::parsing::instance::token__nameof(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "nameof";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable90 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable90;
}
std::optional<size_t> leaf::parsing::instance::token__sizeof(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "sizeof";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable91 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable91;
}
std::optional<size_t> leaf::parsing::instance::token__single_quotation(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        if (current() == '\'')
        {
            count2++;
            next();
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable92 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable92;
}
std::optional<size_t> leaf::parsing::instance::token__scope(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "scope";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable93 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable93;
}
std::optional<size_t> leaf::parsing::instance::token__static(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "static";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable94 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable94;
}
std::optional<size_t> leaf::parsing::instance::token__return(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "return";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable95 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable95;
}
std::optional<size_t> leaf::parsing::instance::token__auto_815(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "<!pragma";
        if (m_contents.length() - m_offset >= 8 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 8, str3, str3 + 8))
        {
            count2++;
            for (size_t i = 0; i < 8; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable96 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable96;
}
std::optional<size_t> leaf::parsing::instance::token__exclamation_greater_then(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "!>";
        if (m_contents.length() - m_offset >= 2 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 2, str3, str3 + 2))
        {
            count2++;
            for (size_t i = 0; i < 2; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable97 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable97;
}
std::optional<size_t> leaf::parsing::instance::token__align(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "align";
        if (m_contents.length() - m_offset >= 5 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 5, str3, str3 + 5))
        {
            count2++;
            for (size_t i = 0; i < 5; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable98 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable98;
}
std::optional<size_t> leaf::parsing::instance::token__size(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "size";
        if (m_contents.length() - m_offset >= 4 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 4, str3, str3 + 4))
        {
            count2++;
            for (size_t i = 0; i < 4; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable99 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable99;
}
std::optional<size_t> leaf::parsing::instance::token__disable(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "disable";
        if (m_contents.length() - m_offset >= 7 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 7, str3, str3 + 7))
        {
            count2++;
            for (size_t i = 0; i < 7; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable100 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable100;
}
std::optional<size_t> leaf::parsing::instance::token__enable(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "enable";
        if (m_contents.length() - m_offset >= 6 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 6, str3, str3 + 6))
        {
            count2++;
            for (size_t i = 0; i < 6; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable101 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable101;
}
std::optional<size_t> leaf::parsing::instance::token__identifier(size_t depth)
{
    resettable resettable1(*this);
    size_t count2 = 0;
    while (current() != '\0' && count2 < 1)
    {
        const char* str3 = "identifier";
        if (m_contents.length() - m_offset >= 10 && std::equal(m_contents.begin() + m_offset, m_contents.begin() + m_offset + 10, str3, str3 + 10))
        {
            count2++;
            for (size_t i = 0; i < 10; i++)
            {
                next();
            }
            continue;
        }
        break;
    }
    if (count2 < 1)
    {
        resettable1.reset();
        return {};
    }
    auto resultVariable102 = m_offset - resettable1.m_offset;
    resettable1.reset();
    return resultVariable102;
}
bool leaf::parsing::instance::m_expor_103(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_arg_item_a>& actual, leaf::parsing::instance::attribute_arg_item_a_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_or(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_or(depth + 1);
    actual->value = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_attribute_arg_item_a(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::attribute_arg_item_a> fake;
    attribute_arg_item_a_state state;
    if (!m_expor_103(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::attribute_arg_item_a> leaf::parsing::instance::p_match_attribute_arg_item_a(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::attribute_arg_item_a>();
    std::shared_ptr<leaf::parsing::instance::attribute_arg_item_a> fake;
    attribute_arg_item_a_state state;
    resettable resettable2(*this);
    if (m_expor_103(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_expor_103(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_colon_expor_104(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_arg_item_b>& actual, leaf::parsing::instance::attribute_arg_item_b_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__colon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_or(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val6;
    skip();
    auto l8 = token__colon(depth + 1).value();
    for (;l8 != 0; l8--)
    {
        next();
    }
    skip();
    auto val9 = lr_match_exp_or(depth + 1);
    actual->value = val9;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_attribute_arg_item_b(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::attribute_arg_item_b> fake;
    attribute_arg_item_b_state state;
    if (!m_ident_colon_expor_104(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::attribute_arg_item_b> leaf::parsing::instance::p_match_attribute_arg_item_b(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::attribute_arg_item_b>();
    std::shared_ptr<leaf::parsing::instance::attribute_arg_item_b> fake;
    attribute_arg_item_b_state state;
    resettable resettable2(*this);
    if (m_ident_colon_expor_104(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_ident_colon_expor_104(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attributeargitema_105(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_a>& actual, leaf::parsing::instance::attribute_args_a_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute_arg_item_a(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute_arg_item_a(depth + 1);
    actual->args.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attributeargitema_106(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_a>& actual, leaf::parsing::instance::attribute_args_a_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute_arg_item_a(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute_arg_item_a(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_attributeargitema_107(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_a>& actual, leaf::parsing::instance::attribute_args_a_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_attribute_arg_item_a(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_attribute_arg_item_a(depth + 1);
    actual->args.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::while108_109(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_a>& actual, leaf::parsing::instance::attribute_args_a_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attributeargitema_106(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_comma_attributeargitema_107(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}), $ref: attribute-arg-item-a (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attributeargitema_106(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_comma_attributeargitema_107(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}), $ref: attribute-arg-item-a (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attributeargitema_106(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_comma_110(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_a>& actual, leaf::parsing::instance::attribute_args_a_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_111(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_a>& actual, leaf::parsing::instance::attribute_args_a_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if112_113(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_a>& actual, leaf::parsing::instance::attribute_args_a_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_comma_110(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_comma_111(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_comma_111(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::p_can_attribute_args_a(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::attribute_args_a> fake;
    attribute_args_a_state state;
    if (!m_attributeargitema_105(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while108_109(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if112_113(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::attribute_args_a> leaf::parsing::instance::p_match_attribute_args_a(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::attribute_args_a>();
    std::shared_ptr<leaf::parsing::instance::attribute_args_a> fake;
    attribute_args_a_state state;
    resettable resettable2(*this);
    if (m_attributeargitema_105(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_attributeargitema_105(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (while108_109(true, fake, state, depth + 1))
    {
        resettable3.reset();
        while108_109(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if112_113(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if112_113(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attributeargitemb_114(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_b>& actual, leaf::parsing::instance::attribute_args_b_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute_arg_item_b(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute_arg_item_b(depth + 1);
    actual->args.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attributeargitemb_115(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_b>& actual, leaf::parsing::instance::attribute_args_b_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute_arg_item_b(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute_arg_item_b(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_attributeargitemb_116(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_b>& actual, leaf::parsing::instance::attribute_args_b_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_attribute_arg_item_b(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_attribute_arg_item_b(depth + 1);
    actual->args.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::while117_118(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_b>& actual, leaf::parsing::instance::attribute_args_b_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attributeargitemb_115(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_comma_attributeargitemb_116(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}), $ref: attribute-arg-item-b (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attributeargitemb_115(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_comma_attributeargitemb_116(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}), $ref: attribute-arg-item-b (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attributeargitemb_115(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_comma_119(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_b>& actual, leaf::parsing::instance::attribute_args_b_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_120(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_b>& actual, leaf::parsing::instance::attribute_args_b_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if121_122(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_args_b>& actual, leaf::parsing::instance::attribute_args_b_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_comma_119(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_comma_120(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_comma_120(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::p_can_attribute_args_b(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::attribute_args_b> fake;
    attribute_args_b_state state;
    if (!m_attributeargitemb_114(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while117_118(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if121_122(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::attribute_args_b> leaf::parsing::instance::p_match_attribute_args_b(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::attribute_args_b>();
    std::shared_ptr<leaf::parsing::instance::attribute_args_b> fake;
    attribute_args_b_state state;
    resettable resettable2(*this);
    if (m_attributeargitemb_114(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_attributeargitemb_114(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (while117_118(true, fake, state, depth + 1))
    {
        resettable3.reset();
        while117_118(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if121_122(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if121_122(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typematch_123(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_item>& actual, leaf::parsing::instance::attribute_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_type_match(depth + 1);
    actual->target_type = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_typematch_roundbracketopen_roundbracketclose_124(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_item>& actual, leaf::parsing::instance::attribute_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_type_match(depth + 1);
    actual->target_type = val6;
    skip();
    auto l8 = token__round_bracket_open(depth + 1).value();
    for (;l8 != 0; l8--)
    {
        next();
    }
    skip();
    auto l10 = token__round_bracket_close(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_typematch_roundbracketopen_attributeargsa_attributeargsb_roundbracketclose_125(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_item>& actual, leaf::parsing::instance::attribute_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_attribute_args_a(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_attribute_args_b(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_type_match(depth + 1);
    actual->target_type = val6;
    skip();
    auto l8 = token__round_bracket_open(depth + 1).value();
    for (;l8 != 0; l8--)
    {
        next();
    }
    skip();
    auto val9 = p_match_attribute_args_a(depth + 1);
    actual->args = val9;
    skip();
    p_match_attribute_args_b(depth + 1);
    skip();
    auto l12 = token__round_bracket_close(depth + 1).value();
    for (;l12 != 0; l12--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_typematch_roundbracketopen_attributeargsa_roundbracketclose_126(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_item>& actual, leaf::parsing::instance::attribute_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_attribute_args_a(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_type_match(depth + 1);
    actual->target_type = val6;
    skip();
    auto l8 = token__round_bracket_open(depth + 1).value();
    for (;l8 != 0; l8--)
    {
        next();
    }
    skip();
    auto val9 = p_match_attribute_args_a(depth + 1);
    actual->args = val9;
    skip();
    auto l11 = token__round_bracket_close(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_typematch_roundbracketopen_attributeargsb_roundbracketclose_127(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_item>& actual, leaf::parsing::instance::attribute_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_attribute_args_b(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_type_match(depth + 1);
    actual->target_type = val6;
    skip();
    auto l8 = token__round_bracket_open(depth + 1).value();
    for (;l8 != 0; l8--)
    {
        next();
    }
    skip();
    auto val9 = p_match_attribute_args_b(depth + 1);
    actual->args = val9;
    skip();
    auto l11 = token__round_bracket_close(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives128(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute_item>& actual, leaf::parsing::instance::attribute_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_typematch_123(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typematch_123(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typematch_roundbracketopen_roundbracketclose_124(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typematch_roundbracketopen_roundbracketclose_124(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typematch_roundbracketopen_attributeargsa_attributeargsb_roundbracketclose_125(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typematch_roundbracketopen_attributeargsa_attributeargsb_roundbracketclose_125(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typematch_roundbracketopen_attributeargsa_roundbracketclose_126(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typematch_roundbracketopen_attributeargsa_roundbracketclose_126(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typematch_roundbracketopen_attributeargsb_roundbracketclose_127(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typematch_roundbracketopen_attributeargsb_roundbracketclose_127(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_attribute_item(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::attribute_item> fake;
    attribute_item_state state;
    if (!alternatives128(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::attribute_item> leaf::parsing::instance::p_match_attribute_item(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::attribute_item>();
    std::shared_ptr<leaf::parsing::instance::attribute_item> fake;
    attribute_item_state state;
    resettable resettable2(*this);
    if (alternatives128(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives128(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_squarebracketopen_129(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_attributeitem_130(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute_item(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attributeitem_131(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute_item(depth + 1);
    actual->items.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attributeitem_132(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute_item(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_attributeitem_133(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_attribute_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_attribute_item(depth + 1);
    actual->items.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::while134_135(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attributeitem_132(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_comma_attributeitem_133(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}), $ref: attribute-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attributeitem_132(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_comma_attributeitem_133(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}), $ref: attribute-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attributeitem_132(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_comma_136(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_137(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if138_139(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_comma_136(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_comma_137(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_comma_137(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::if140_141(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_attributeitem_130(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_attributeitem_131(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            while134_135(true, actual, state, depth + 1);
            if138_139(true, actual, state, depth + 1);
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_attributeitem_131(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            while134_135(false, actual, state, depth + 1);
            if138_139(false, actual, state, depth + 1);
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_squarebracketclose_142(bool is_can, std::shared_ptr<leaf::parsing::instance::attribute>& actual, leaf::parsing::instance::attribute_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_attribute(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::attribute> fake;
    attribute_state state;
    if (!m_squarebracketopen_129(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if140_141(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_squarebracketclose_142(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::attribute> leaf::parsing::instance::p_match_attribute(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::attribute>();
    std::shared_ptr<leaf::parsing::instance::attribute> fake;
    attribute_state state;
    resettable resettable2(*this);
    if (m_squarebracketopen_129(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_squarebracketopen_129(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if140_141(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if140_141(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_squarebracketclose_142(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_squarebracketclose_142(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_encapsulation_contract_ident_143(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_encapsulation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__contract(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_encapsulation(depth + 1);
    actual->scope = val6;
    skip();
    auto l8 = token__contract(depth + 1).value();
    for (;l8 != 0; l8--)
    {
        next();
    }
    skip();
    auto val9 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val9;
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_144(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_145(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if146_147(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_144(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_145(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_145(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketopen_148(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketclose_149(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_contractmethod_150(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract_method(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_contract_method(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_contractconstructor_151(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract_constructor(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_contract_constructor(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_contractindexer_152(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract_indexer(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_contract_indexer(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_contractoperatorbinaryoverload_153(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract_operator_binary_overload(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_contract_operator_binary_overload(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_contractoperatorunaryoverload_154(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract_operator_unary_overload(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_contract_operator_unary_overload(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_contractoperatornullaroverload_155(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract_operator_nullar_overload(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_contract_operator_nullar_overload(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_contractproperty_156(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract_property(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_contract_property(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_contractfield_157(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract_field(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_contract_field(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives158(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_contractmethod_150(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contractmethod_150(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_contractconstructor_151(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contractconstructor_151(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_contractindexer_152(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contractindexer_152(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_contractoperatorbinaryoverload_153(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contractoperatorbinaryoverload_153(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_contractoperatorunaryoverload_154(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contractoperatorunaryoverload_154(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_contractoperatornullaroverload_155(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contractoperatornullaroverload_155(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_contractproperty_156(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contractproperty_156(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_contractfield_157(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contractfield_157(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while159_160(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_curlybracketclose_149(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            alternatives158(true, actual, state, depth + 1);
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_149(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            alternatives158(false, actual, state, depth + 1);
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_149(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketclose_161(bool is_can, std::shared_ptr<leaf::parsing::instance::contract>& actual, leaf::parsing::instance::contract_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract> fake;
    contract_state state;
    if (!m_encapsulation_contract_ident_143(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if146_147(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketopen_148(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while159_160(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketclose_161(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract> leaf::parsing::instance::p_match_contract(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract>();
    std::shared_ptr<leaf::parsing::instance::contract> fake;
    contract_state state;
    resettable resettable2(*this);
    if (m_encapsulation_contract_ident_143(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_encapsulation_contract_ident_143(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if146_147(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if146_147(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_curlybracketopen_148(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_curlybracketopen_148(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (while159_160(true, fake, state, depth + 1))
    {
        resettable5.reset();
        while159_160(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (m_curlybracketclose_161(true, fake, state, depth + 1))
    {
        resettable6.reset();
        m_curlybracketclose_161(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typematch_ident_contractmethodarglist_semicolon_162(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method>& actual, leaf::parsing::instance::contract_method_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_contract_method_arglist(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__semicolon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_type_match(depth + 1);
    actual->return_type = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val7;
    skip();
    auto val8 = p_match_contract_method_arglist(depth + 1);
    actual->arglist = val8;
    skip();
    auto l10 = token__semicolon(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract_method(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_method> fake;
    contract_method_state state;
    if (!m_typematch_ident_contractmethodarglist_semicolon_162(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_method> leaf::parsing::instance::p_match_contract_method(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_method>();
    std::shared_ptr<leaf::parsing::instance::contract_method> fake;
    contract_method_state state;
    resettable resettable2(*this);
    if (m_typematch_ident_contractmethodarglist_semicolon_162(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_typematch_ident_contractmethodarglist_semicolon_162(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_contractmethodarglist_semicolon_163(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_constructor>& actual, leaf::parsing::instance::contract_constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_contract_method_arglist(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__semicolon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val6;
    skip();
    auto val7 = p_match_contract_method_arglist(depth + 1);
    actual->arglist = val7;
    skip();
    auto l9 = token__semicolon(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract_constructor(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_constructor> fake;
    contract_constructor_state state;
    if (!m_ident_contractmethodarglist_semicolon_163(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_constructor> leaf::parsing::instance::p_match_contract_constructor(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_constructor>();
    std::shared_ptr<leaf::parsing::instance::contract_constructor> fake;
    contract_constructor_state state;
    resettable resettable2(*this);
    if (m_ident_contractmethodarglist_semicolon_163(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_ident_contractmethodarglist_semicolon_163(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typematch_contractmethodarglistindexer_164(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_indexer>& actual, leaf::parsing::instance::contract_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_contract_method_arglist_indexer(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_type_match(depth + 1);
    actual->target_type = val2;
    skip();
    auto val3 = p_match_contract_method_arglist_indexer(depth + 1);
    actual->arglist = val3;
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_get_semicolon_set_semicolon_curlybracketclose_165(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_indexer>& actual, leaf::parsing::instance::contract_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__get(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__semicolon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__set(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l10 = token__semicolon(depth + 1);
    if (l10.has_value())
    {
        for (auto i11 = l10.value(); i11 != 0; i11--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l12 = token__curly_bracket_close(depth + 1);
    if (l12.has_value())
    {
        for (auto i13 = l12.value(); i13 != 0; i13--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l15 = token__curly_bracket_open(depth + 1).value();
    for (;l15 != 0; l15--)
    {
        next();
    }
    skip();
    auto l17 = token__get(depth + 1).value();
    for (;l17 != 0; l17--)
    {
        next();
    }
    skip();
    auto l19 = token__semicolon(depth + 1).value();
    for (;l19 != 0; l19--)
    {
        next();
    }
    skip();
    auto l21 = token__set(depth + 1).value();
    for (;l21 != 0; l21--)
    {
        next();
    }
    skip();
    auto l23 = token__semicolon(depth + 1).value();
    for (;l23 != 0; l23--)
    {
        next();
    }
    skip();
    auto l25 = token__curly_bracket_close(depth + 1).value();
    for (;l25 != 0; l25--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_set = true;
    }
    if (!is_can)
    {
        actual->is_get = true;
    }
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_get_semicolon_curlybracketclose_166(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_indexer>& actual, leaf::parsing::instance::contract_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__get(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__semicolon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__curly_bracket_close(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l11 = token__curly_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto l13 = token__get(depth + 1).value();
    for (;l13 != 0; l13--)
    {
        next();
    }
    skip();
    auto l15 = token__semicolon(depth + 1).value();
    for (;l15 != 0; l15--)
    {
        next();
    }
    skip();
    auto l17 = token__curly_bracket_close(depth + 1).value();
    for (;l17 != 0; l17--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_get = true;
    }
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_set_semicolon_curlybracketclose_167(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_indexer>& actual, leaf::parsing::instance::contract_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__set(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__semicolon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__curly_bracket_close(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l11 = token__curly_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto l13 = token__set(depth + 1).value();
    for (;l13 != 0; l13--)
    {
        next();
    }
    skip();
    auto l15 = token__semicolon(depth + 1).value();
    for (;l15 != 0; l15--)
    {
        next();
    }
    skip();
    auto l17 = token__curly_bracket_close(depth + 1).value();
    for (;l17 != 0; l17--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_set = true;
    }
    return true;
}
bool leaf::parsing::instance::alternatives168(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_indexer>& actual, leaf::parsing::instance::contract_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_curlybracketopen_get_semicolon_set_semicolon_curlybracketclose_165(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketopen_get_semicolon_set_semicolon_curlybracketclose_165(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_curlybracketopen_get_semicolon_curlybracketclose_166(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketopen_get_semicolon_curlybracketclose_166(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_curlybracketopen_set_semicolon_curlybracketclose_167(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketopen_set_semicolon_curlybracketclose_167(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_contract_indexer(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_indexer> fake;
    contract_indexer_state state;
    if (!m_typematch_contractmethodarglistindexer_164(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives168(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_indexer> leaf::parsing::instance::p_match_contract_indexer(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_indexer>();
    std::shared_ptr<leaf::parsing::instance::contract_indexer> fake;
    contract_indexer_state state;
    resettable resettable2(*this);
    if (m_typematch_contractmethodarglistindexer_164(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_typematch_contractmethodarglistindexer_164(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives168(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives168(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typematch_operator_169(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__operator(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_type_match(depth + 1);
    actual->target_type = val4;
    skip();
    auto l6 = token__operator(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_roundbracketopen_typematch_roundbracketclose_170(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__round_bracket_open(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_type_match(depth + 1);
    actual->left = val8;
    skip();
    auto l10 = token__round_bracket_close(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_plus_171(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_plus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_plus(depth + 1).value(), tok::PLUS);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_minus_172(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_minus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_minus(depth + 1).value(), tok::MINUS);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_star_173(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_star(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_star(depth + 1).value(), tok::STAR);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_slash_174(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_slash(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_slash(depth + 1).value(), tok::SLASH);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_lessthenlessthenlessthen_175(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_less_then_less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_less_then_less_then(depth + 1).value(), tok::_LESS_THEN_LESS_THEN_LESS_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_lessthenlessthen_176(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_less_then(depth + 1).value(), tok::_LESS_THEN_LESS_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_lessthenequal_177(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_equal(depth + 1).value(), tok::_LESS_THEN_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_lessthen_178(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then(depth + 1).value(), tok::_LESS_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_greaterthengreaterthengreaterthen_179(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_greater_then_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_greater_then_greater_then(depth + 1).value(), tok::_GREATER_THEN_GREATER_THEN_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_greaterthengreaterthen_180(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_greater_then(depth + 1).value(), tok::_GREATER_THEN_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_greaterthenequal_181(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_equal(depth + 1).value(), tok::_GREATER_THEN_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_greaterthen_182(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then(depth + 1).value(), tok::_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_verticalbarverticalbar_183(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__vertical_bar_vertical_bar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__vertical_bar_vertical_bar(depth + 1).value(), tok::_VERTICAL_BAR_VERTICAL_BAR);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_verticalbar_184(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__vertical_bar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__vertical_bar(depth + 1).value(), tok::_VERTICAL_BAR);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ampersandampersand_185(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__ampersand_ampersand(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__ampersand_ampersand(depth + 1).value(), tok::_AMPERSAND_AMPERSAND);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ampersand_186(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__ampersand(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__ampersand(depth + 1).value(), tok::_AMPERSAND);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_equalequalequal_187(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal_equal_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__equal_equal_equal(depth + 1).value(), tok::_EQUAL_EQUAL_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_equalequal_188(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__equal_equal(depth + 1).value(), tok::_EQUAL_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_exclamationequal_189(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__exclamation_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__exclamation_equal(depth + 1).value(), tok::_EXCLAMATION_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_circumflex_190(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__circumflex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__circumflex(depth + 1).value(), tok::_CIRCUMFLEX);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives191(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_plus_171(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_plus_171(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_minus_172(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_minus_172(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_star_173(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_star_173(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_slash_174(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_slash_174(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_lessthenlessthenlessthen_175(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_lessthenlessthenlessthen_175(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_lessthenlessthen_176(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_lessthenlessthen_176(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_lessthenequal_177(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_lessthenequal_177(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_lessthen_178(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_lessthen_178(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_greaterthengreaterthengreaterthen_179(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_greaterthengreaterthengreaterthen_179(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_greaterthengreaterthen_180(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_greaterthengreaterthen_180(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_greaterthenequal_181(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_greaterthenequal_181(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_greaterthen_182(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_greaterthen_182(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_verticalbarverticalbar_183(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_verticalbarverticalbar_183(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_verticalbar_184(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_verticalbar_184(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ampersandampersand_185(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ampersandampersand_185(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ampersand_186(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ampersand_186(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_equalequalequal_187(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_equalequalequal_187(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_equalequal_188(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_equalequal_188(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_exclamationequal_189(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_exclamationequal_189(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_circumflex_190(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_circumflex_190(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_roundbracketopen_typematch_roundbracketclose_semicolon_192(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload>& actual, leaf::parsing::instance::contract_operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__semicolon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__round_bracket_open(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto val10 = p_match_type_match(depth + 1);
    actual->right = val10;
    skip();
    auto l12 = token__round_bracket_close(depth + 1).value();
    for (;l12 != 0; l12--)
    {
        next();
    }
    skip();
    auto l14 = token__semicolon(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract_operator_binary_overload(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload> fake;
    contract_operator_binary_overload_state state;
    if (!m_typematch_operator_169(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketopen_typematch_roundbracketclose_170(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives191(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketopen_typematch_roundbracketclose_semicolon_192(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload> leaf::parsing::instance::p_match_contract_operator_binary_overload(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_operator_binary_overload>();
    std::shared_ptr<leaf::parsing::instance::contract_operator_binary_overload> fake;
    contract_operator_binary_overload_state state;
    resettable resettable2(*this);
    if (m_typematch_operator_169(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_typematch_operator_169(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_roundbracketopen_typematch_roundbracketclose_170(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_roundbracketopen_typematch_roundbracketclose_170(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (alternatives191(true, fake, state, depth + 1))
    {
        resettable4.reset();
        alternatives191(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_roundbracketopen_typematch_roundbracketclose_semicolon_192(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_roundbracketopen_typematch_roundbracketclose_semicolon_192(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typematch_operator_193(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload>& actual, leaf::parsing::instance::contract_operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__operator(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_type_match(depth + 1);
    actual->target_type = val4;
    skip();
    auto l6 = token__operator(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_plus_194(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload>& actual, leaf::parsing::instance::contract_operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_plus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_plus(depth + 1).value(), tok::PLUS);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_minus_195(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload>& actual, leaf::parsing::instance::contract_operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_minus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_minus(depth + 1).value(), tok::MINUS);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_exclamation_196(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload>& actual, leaf::parsing::instance::contract_operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__exclamation(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__exclamation(depth + 1).value(), tok::_EXCLAMATION);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_tilde_197(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload>& actual, leaf::parsing::instance::contract_operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__tilde(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__tilde(depth + 1).value(), tok::_TILDE);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives198(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload>& actual, leaf::parsing::instance::contract_operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_plus_194(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_plus_194(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_minus_195(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_minus_195(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_exclamation_196(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_exclamation_196(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_tilde_197(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_tilde_197(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_roundbracketopen_typematch_roundbracketclose_semicolon_199(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload>& actual, leaf::parsing::instance::contract_operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__semicolon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__round_bracket_open(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto val10 = p_match_type_match(depth + 1);
    actual->right = val10;
    skip();
    auto l12 = token__round_bracket_close(depth + 1).value();
    for (;l12 != 0; l12--)
    {
        next();
    }
    skip();
    auto l14 = token__semicolon(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract_operator_unary_overload(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload> fake;
    contract_operator_unary_overload_state state;
    if (!m_typematch_operator_193(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives198(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketopen_typematch_roundbracketclose_semicolon_199(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload> leaf::parsing::instance::p_match_contract_operator_unary_overload(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_operator_unary_overload>();
    std::shared_ptr<leaf::parsing::instance::contract_operator_unary_overload> fake;
    contract_operator_unary_overload_state state;
    resettable resettable2(*this);
    if (m_typematch_operator_193(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_typematch_operator_193(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives198(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives198(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_roundbracketopen_typematch_roundbracketclose_semicolon_199(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_roundbracketopen_typematch_roundbracketclose_semicolon_199(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_methodmeta_operator_200(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_nullar_overload>& actual, leaf::parsing::instance::contract_operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_meta(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__operator(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_method_meta(depth + 1);
    actual->meta = val4;
    skip();
    auto l6 = token__operator(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_dot_201(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_nullar_overload>& actual, leaf::parsing::instance::contract_operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__dot(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__dot(depth + 1).value(), tok::_DOT);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_minusgreaterthen_202(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_nullar_overload>& actual, leaf::parsing::instance::contract_operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__minus_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__minus_greater_then(depth + 1).value(), tok::_MINUS_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives203(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_nullar_overload>& actual, leaf::parsing::instance::contract_operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_dot_201(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_dot_201(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_minusgreaterthen_202(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_minusgreaterthen_202(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_semicolon_204(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_operator_nullar_overload>& actual, leaf::parsing::instance::contract_operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__semicolon(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__semicolon(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract_operator_nullar_overload(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_operator_nullar_overload> fake;
    contract_operator_nullar_overload_state state;
    if (!m_methodmeta_operator_200(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives203(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_semicolon_204(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_operator_nullar_overload> leaf::parsing::instance::p_match_contract_operator_nullar_overload(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_operator_nullar_overload>();
    std::shared_ptr<leaf::parsing::instance::contract_operator_nullar_overload> fake;
    contract_operator_nullar_overload_state state;
    resettable resettable2(*this);
    if (m_methodmeta_operator_200(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_methodmeta_operator_200(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives203(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives203(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_semicolon_204(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_semicolon_204(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typematch_ident_205(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_property>& actual, leaf::parsing::instance::contract_property_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_type_match(depth + 1);
    actual->target_type = val4;
    skip();
    auto val5 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_get_semicolon_set_semicolon_curlybracketclose_206(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_property>& actual, leaf::parsing::instance::contract_property_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__get(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__semicolon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__set(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l10 = token__semicolon(depth + 1);
    if (l10.has_value())
    {
        for (auto i11 = l10.value(); i11 != 0; i11--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l12 = token__curly_bracket_close(depth + 1);
    if (l12.has_value())
    {
        for (auto i13 = l12.value(); i13 != 0; i13--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l15 = token__curly_bracket_open(depth + 1).value();
    for (;l15 != 0; l15--)
    {
        next();
    }
    skip();
    auto l17 = token__get(depth + 1).value();
    for (;l17 != 0; l17--)
    {
        next();
    }
    skip();
    auto l19 = token__semicolon(depth + 1).value();
    for (;l19 != 0; l19--)
    {
        next();
    }
    skip();
    auto l21 = token__set(depth + 1).value();
    for (;l21 != 0; l21--)
    {
        next();
    }
    skip();
    auto l23 = token__semicolon(depth + 1).value();
    for (;l23 != 0; l23--)
    {
        next();
    }
    skip();
    auto l25 = token__curly_bracket_close(depth + 1).value();
    for (;l25 != 0; l25--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_set = true;
    }
    if (!is_can)
    {
        actual->is_get = true;
    }
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_get_semicolon_curlybracketclose_207(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_property>& actual, leaf::parsing::instance::contract_property_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__get(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__semicolon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__curly_bracket_close(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l11 = token__curly_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto l13 = token__get(depth + 1).value();
    for (;l13 != 0; l13--)
    {
        next();
    }
    skip();
    auto l15 = token__semicolon(depth + 1).value();
    for (;l15 != 0; l15--)
    {
        next();
    }
    skip();
    auto l17 = token__curly_bracket_close(depth + 1).value();
    for (;l17 != 0; l17--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_get = true;
    }
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_set_semicolon_curlybracketclose_208(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_property>& actual, leaf::parsing::instance::contract_property_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__set(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__semicolon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__curly_bracket_close(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l11 = token__curly_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto l13 = token__set(depth + 1).value();
    for (;l13 != 0; l13--)
    {
        next();
    }
    skip();
    auto l15 = token__semicolon(depth + 1).value();
    for (;l15 != 0; l15--)
    {
        next();
    }
    skip();
    auto l17 = token__curly_bracket_close(depth + 1).value();
    for (;l17 != 0; l17--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_set = true;
    }
    return true;
}
bool leaf::parsing::instance::alternatives209(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_property>& actual, leaf::parsing::instance::contract_property_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_curlybracketopen_get_semicolon_set_semicolon_curlybracketclose_206(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketopen_get_semicolon_set_semicolon_curlybracketclose_206(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_curlybracketopen_get_semicolon_curlybracketclose_207(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketopen_get_semicolon_curlybracketclose_207(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_curlybracketopen_set_semicolon_curlybracketclose_208(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketopen_set_semicolon_curlybracketclose_208(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_contract_property(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_property> fake;
    contract_property_state state;
    if (!m_typematch_ident_205(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives209(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_property> leaf::parsing::instance::p_match_contract_property(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_property>();
    std::shared_ptr<leaf::parsing::instance::contract_property> fake;
    contract_property_state state;
    resettable resettable2(*this);
    if (m_typematch_ident_205(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_typematch_ident_205(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives209(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives209(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typematch_ident_semicolon_210(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_field>& actual, leaf::parsing::instance::contract_field_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__semicolon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_type_match(depth + 1);
    actual->target_type = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val7;
    skip();
    auto l9 = token__semicolon(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract_field(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_field> fake;
    contract_field_state state;
    if (!m_typematch_ident_semicolon_210(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_field> leaf::parsing::instance::p_match_contract_field(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_field>();
    std::shared_ptr<leaf::parsing::instance::contract_field> fake;
    contract_field_state state;
    resettable resettable2(*this);
    if (m_typematch_ident_semicolon_210(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_typematch_ident_semicolon_210(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_roundbracketopen_211(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_typematch_212(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_type_match(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_typematch_213(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_type_match(depth + 1);
    actual->args.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_roundbracketclose_214(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_typematch_215(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_type_match(depth + 1);
    actual->args.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_216(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives217(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_comma_typematch_215(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_typematch_215(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_comma_216(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_216(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { ,, type-match, , }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while218_219(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_roundbracketclose_214(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives217(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_roundbracketclose_214(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives217(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives217(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_roundbracketclose_214(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::if220_221(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_typematch_212(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_typematch_213(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: type-match (XCG.Parsing.Production) }", depth);
                return false;
            }
            while218_219(true, actual, state, depth + 1);
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_typematch_213(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: type-match (XCG.Parsing.Production) }", depth);
                return false;
            }
            while218_219(false, actual, state, depth + 1);
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_roundbracketclose_222(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist>& actual, leaf::parsing::instance::contract_method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract_method_arglist(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_method_arglist> fake;
    contract_method_arglist_state state;
    if (!m_roundbracketopen_211(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if220_221(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketclose_222(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_method_arglist> leaf::parsing::instance::p_match_contract_method_arglist(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_method_arglist>();
    std::shared_ptr<leaf::parsing::instance::contract_method_arglist> fake;
    contract_method_arglist_state state;
    resettable resettable2(*this);
    if (m_roundbracketopen_211(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_roundbracketopen_211(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if220_221(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if220_221(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_roundbracketclose_222(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_roundbracketclose_222(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_squarebracketopen_223(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer>& actual, leaf::parsing::instance::contract_method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_typematch_224(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer>& actual, leaf::parsing::instance::contract_method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_type_match(depth + 1);
    actual->args.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_squarebracketclose_225(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer>& actual, leaf::parsing::instance::contract_method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_typematch_226(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer>& actual, leaf::parsing::instance::contract_method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_type_match(depth + 1);
    actual->args.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_227(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer>& actual, leaf::parsing::instance::contract_method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives228(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer>& actual, leaf::parsing::instance::contract_method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_comma_typematch_226(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_typematch_226(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_comma_227(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_227(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { ,, type-match, , }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while229_230(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer>& actual, leaf::parsing::instance::contract_method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_squarebracketclose_225(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives228(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_squarebracketclose_225(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives228(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives228(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_squarebracketclose_225(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_squarebracketclose_231(bool is_can, std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer>& actual, leaf::parsing::instance::contract_method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_contract_method_arglist_indexer(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer> fake;
    contract_method_arglist_indexer_state state;
    if (!m_squarebracketopen_223(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_typematch_224(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while229_230(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_squarebracketclose_231(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer> leaf::parsing::instance::p_match_contract_method_arglist_indexer(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::contract_method_arglist_indexer>();
    std::shared_ptr<leaf::parsing::instance::contract_method_arglist_indexer> fake;
    contract_method_arglist_indexer_state state;
    resettable resettable2(*this);
    if (m_squarebracketopen_223(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_squarebracketopen_223(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_typematch_224(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_typematch_224(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (while229_230(true, fake, state, depth + 1))
    {
        resettable4.reset();
        while229_230(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_squarebracketclose_231(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_squarebracketclose_231(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_curlybracketclose_232(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_using_233(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_using_(depth + 1);
    actual->usings.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_controlstructure_234(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_control_structure(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_control_structure(depth + 1);
    actual->body.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_statement_235(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_statement(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_statement(depth + 1);
    actual->body.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives236(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_using_233(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_using_233(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_controlstructure_234(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_controlstructure_234(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_statement_235(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_statement_235(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { using, control-structure, statement }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while237_238(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_curlybracketclose_232(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives236(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_232(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives236(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives236(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_232(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketclose_239(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_240(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    while237_238(false, actual, state, depth + 1);
    if (m_curlybracketclose_239(false, actual, state, depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        return false;
    }
    else
    {
        report("Failed to match { $ref: } ({ Token: } (})}) }", depth);
        return false;
    }
    return true;
}
bool leaf::parsing::instance::m_using_241(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_using_(depth + 1);
    actual->usings.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_controlstructure_242(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_control_structure(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_control_structure(depth + 1);
    actual->body.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_statement_243(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_statement(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_statement(depth + 1);
    actual->body.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives244(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_using_241(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_using_241(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_controlstructure_242(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_controlstructure_242(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_statement_243(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_statement_243(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_equalgreaterthen_245(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__equal_greater_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    alternatives244(false, actual, state, depth + 1);
    return true;
}
bool leaf::parsing::instance::alternatives246(bool is_can, std::shared_ptr<leaf::parsing::instance::scope>& actual, leaf::parsing::instance::scope_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_curlybracketopen_240(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketopen_240(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_equalgreaterthen_245(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_equalgreaterthen_245(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_scope(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::scope> fake;
    scope_state state;
    if (!alternatives246(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::scope> leaf::parsing::instance::p_match_scope(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::scope>();
    std::shared_ptr<leaf::parsing::instance::scope> fake;
    scope_state state;
    resettable resettable2(*this);
    if (alternatives246(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives246(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_curlybracketclose_247(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_using_248(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_using_(depth + 1);
    actual->usings.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_controlstructure_249(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_control_structure(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_control_structure(depth + 1);
    actual->body.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_statement_250(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_statement(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_statement(depth + 1);
    actual->body.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives251(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_using_248(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_using_248(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_controlstructure_249(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_controlstructure_249(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_statement_250(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_statement_250(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { using, control-structure, statement }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while252_253(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_curlybracketclose_247(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives251(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_247(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives251(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives251(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_247(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketclose_254(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_255(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    while252_253(false, actual, state, depth + 1);
    if (m_curlybracketclose_254(false, actual, state, depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        return false;
    }
    else
    {
        report("Failed to match { $ref: } ({ Token: } (})}) }", depth);
        return false;
    }
    return true;
}
bool leaf::parsing::instance::m_using_256(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_using_(depth + 1);
    actual->usings.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_controlstructure_257(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_control_structure(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_control_structure(depth + 1);
    actual->body.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_statement_258(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_statement(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_statement(depth + 1);
    actual->body.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives259(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_curlybracketopen_255(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketopen_255(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_using_256(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_using_256(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_controlstructure_257(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_controlstructure_257(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_statement_258(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_statement_258(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_equalgreaterthen_260(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__equal_greater_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    alternatives259(false, actual, state, depth + 1);
    return true;
}
bool leaf::parsing::instance::alternatives261(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_lambda>& actual, leaf::parsing::instance::scope_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_equalgreaterthen_260(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_equalgreaterthen_260(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_scope_lambda(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::scope_lambda> fake;
    scope_lambda_state state;
    if (!alternatives261(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::scope_lambda> leaf::parsing::instance::p_match_scope_lambda(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::scope_lambda>();
    std::shared_ptr<leaf::parsing::instance::scope_lambda> fake;
    scope_lambda_state state;
    resettable resettable2(*this);
    if (alternatives261(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives261(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_curlybracketopen_262(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_getset>& actual, leaf::parsing::instance::scope_getset_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_get_scope_set_scope_263(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_getset>& actual, leaf::parsing::instance::scope_getset_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__get(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__set(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__get(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_scope(depth + 1);
    actual->get = val8;
    skip();
    auto l10 = token__set(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    auto val11 = p_match_scope(depth + 1);
    actual->set = val11;
    skip();
    return true;
}
bool leaf::parsing::instance::m_set_scope_get_scope_264(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_getset>& actual, leaf::parsing::instance::scope_getset_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__set(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__get(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__set(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_scope(depth + 1);
    actual->set = val8;
    skip();
    auto l10 = token__get(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    auto val11 = p_match_scope(depth + 1);
    actual->get = val11;
    skip();
    return true;
}
bool leaf::parsing::instance::m_get_scope_265(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_getset>& actual, leaf::parsing::instance::scope_getset_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__get(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__get(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_scope(depth + 1);
    actual->get = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::m_set_scope_266(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_getset>& actual, leaf::parsing::instance::scope_getset_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__set(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__set(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_scope(depth + 1);
    actual->set = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives267(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_getset>& actual, leaf::parsing::instance::scope_getset_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_get_scope_set_scope_263(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_get_scope_set_scope_263(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_set_scope_get_scope_264(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_set_scope_get_scope_264(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_get_scope_265(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_get_scope_265(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_set_scope_266(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_set_scope_266(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_curlybracketclose_268(bool is_can, std::shared_ptr<leaf::parsing::instance::scope_getset>& actual, leaf::parsing::instance::scope_getset_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_scope_getset(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::scope_getset> fake;
    scope_getset_state state;
    if (!m_curlybracketopen_262(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives267(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketclose_268(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::scope_getset> leaf::parsing::instance::p_match_scope_getset(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::scope_getset>();
    std::shared_ptr<leaf::parsing::instance::scope_getset> fake;
    scope_getset_state state;
    resettable resettable2(*this);
    if (m_curlybracketopen_262(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_curlybracketopen_262(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives267(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives267(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_curlybracketclose_268(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_curlybracketclose_268(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_scope_269(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure_body>& actual, leaf::parsing::instance::control_structure_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_scope(depth + 1);
    actual->body = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_controlstructure_270(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure_body>& actual, leaf::parsing::instance::control_structure_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_control_structure(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_control_structure(depth + 1);
    actual->body = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_statement_271(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure_body>& actual, leaf::parsing::instance::control_structure_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_statement(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_statement(depth + 1);
    actual->body = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives272(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure_body>& actual, leaf::parsing::instance::control_structure_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_scope_269(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scope_269(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_controlstructure_270(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_controlstructure_270(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_statement_271(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_statement_271(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_control_structure_body(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::control_structure_body> fake;
    control_structure_body_state state;
    if (!alternatives272(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::control_structure_body> leaf::parsing::instance::p_match_control_structure_body(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::control_structure_body>();
    std::shared_ptr<leaf::parsing::instance::control_structure_body> fake;
    control_structure_body_state state;
    resettable resettable2(*this);
    if (alternatives272(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives272(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_while_roundbracketopen_expression_roundbracketclose_controlstructurebody_273(bool is_can, std::shared_ptr<leaf::parsing::instance::while_loop>& actual, leaf::parsing::instance::while_loop_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__while(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__round_bracket_close(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_control_structure_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__while(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto l11 = token__round_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto val12 = p_match_expression(depth + 1);
    actual->condition = val12;
    skip();
    auto l14 = token__round_bracket_close(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    auto val15 = p_match_control_structure_body(depth + 1);
    actual->body = val15;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_while_loop(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::while_loop> fake;
    while_loop_state state;
    if (!m_while_roundbracketopen_expression_roundbracketclose_controlstructurebody_273(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::while_loop> leaf::parsing::instance::p_match_while_loop(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::while_loop>();
    std::shared_ptr<leaf::parsing::instance::while_loop> fake;
    while_loop_state state;
    resettable resettable2(*this);
    if (m_while_roundbracketopen_expression_roundbracketclose_controlstructurebody_273(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_while_roundbracketopen_expression_roundbracketclose_controlstructurebody_273(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_if_roundbracketopen_expression_roundbracketclose_controlstructurebody_274(bool is_can, std::shared_ptr<leaf::parsing::instance::if_body>& actual, leaf::parsing::instance::if_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__if(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__round_bracket_close(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_control_structure_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__if(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto l11 = token__round_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto val12 = p_match_expression(depth + 1);
    actual->condition = val12;
    skip();
    auto l14 = token__round_bracket_close(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    auto val15 = p_match_control_structure_body(depth + 1);
    actual->body = val15;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_if_body(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::if_body> fake;
    if_body_state state;
    if (!m_if_roundbracketopen_expression_roundbracketclose_controlstructurebody_274(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::if_body> leaf::parsing::instance::p_match_if_body(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::if_body>();
    std::shared_ptr<leaf::parsing::instance::if_body> fake;
    if_body_state state;
    resettable resettable2(*this);
    if (m_if_roundbracketopen_expression_roundbracketclose_controlstructurebody_274(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_if_roundbracketopen_expression_roundbracketclose_controlstructurebody_274(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_else_controlstructurebody_275(bool is_can, std::shared_ptr<leaf::parsing::instance::else_body>& actual, leaf::parsing::instance::else_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__else(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_control_structure_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__else(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_control_structure_body(depth + 1);
    actual->else_body = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_else_body(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::else_body> fake;
    else_body_state state;
    if (!m_else_controlstructurebody_275(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::else_body> leaf::parsing::instance::p_match_else_body(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::else_body>();
    std::shared_ptr<leaf::parsing::instance::else_body> fake;
    else_body_state state;
    resettable resettable2(*this);
    if (m_else_controlstructurebody_275(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_else_controlstructurebody_275(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_for_roundbracketopen_276(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__for(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__for(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto l9 = token__round_bracket_open(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_277(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_expression(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_278(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_expression(depth + 1);
    actual->pre = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if279_280(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_expression_277(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_expression_278(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_expression_278(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_semicolon_281(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__semicolon(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__semicolon(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_282(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_expression(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_283(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_expression(depth + 1);
    actual->condition = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if284_285(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_expression_282(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_expression_283(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_expression_283(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_semicolon_286(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__semicolon(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__semicolon(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_287(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_expression(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_288(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_expression(depth + 1);
    actual->post_inner = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if289_290(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_expression_287(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_expression_288(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_expression_288(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_roundbracketclose_controlstructurebody_291(bool is_can, std::shared_ptr<leaf::parsing::instance::for_body>& actual, leaf::parsing::instance::for_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_control_structure_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_control_structure_body(depth + 1);
    actual->body = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_for_body(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::for_body> fake;
    for_body_state state;
    if (!m_for_roundbracketopen_276(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if279_280(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_semicolon_281(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if284_285(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_semicolon_286(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if289_290(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketclose_controlstructurebody_291(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::for_body> leaf::parsing::instance::p_match_for_body(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::for_body>();
    std::shared_ptr<leaf::parsing::instance::for_body> fake;
    for_body_state state;
    resettable resettable2(*this);
    if (m_for_roundbracketopen_276(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_for_roundbracketopen_276(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if279_280(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if279_280(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_semicolon_281(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_semicolon_281(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (if284_285(true, fake, state, depth + 1))
    {
        resettable5.reset();
        if284_285(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (m_semicolon_286(true, fake, state, depth + 1))
    {
        resettable6.reset();
        m_semicolon_286(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable7(*this);
    if (if289_290(true, fake, state, depth + 1))
    {
        resettable7.reset();
        if289_290(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable8(*this);
    if (m_roundbracketclose_controlstructurebody_291(true, fake, state, depth + 1))
    {
        resettable8.reset();
        m_roundbracketclose_controlstructurebody_291(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_for_roundbracketopen_declaration_colon_expression_roundbracketclose_controlstructurebody_292(bool is_can, std::shared_ptr<leaf::parsing::instance::for_each_body>& actual, leaf::parsing::instance::for_each_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__for(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_declaration(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__colon(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__round_bracket_close(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_control_structure_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l11 = token__for(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto l13 = token__round_bracket_open(depth + 1).value();
    for (;l13 != 0; l13--)
    {
        next();
    }
    skip();
    auto val14 = p_match_declaration(depth + 1);
    actual->pre = val14;
    skip();
    auto l16 = token__colon(depth + 1).value();
    for (;l16 != 0; l16--)
    {
        next();
    }
    skip();
    auto val17 = p_match_expression(depth + 1);
    actual->exp = val17;
    skip();
    auto l19 = token__round_bracket_close(depth + 1).value();
    for (;l19 != 0; l19--)
    {
        next();
    }
    skip();
    auto val20 = p_match_control_structure_body(depth + 1);
    actual->body = val20;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_for_each_body(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::for_each_body> fake;
    for_each_body_state state;
    if (!m_for_roundbracketopen_declaration_colon_expression_roundbracketclose_controlstructurebody_292(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::for_each_body> leaf::parsing::instance::p_match_for_each_body(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::for_each_body>();
    std::shared_ptr<leaf::parsing::instance::for_each_body> fake;
    for_each_body_state state;
    resettable resettable2(*this);
    if (m_for_roundbracketopen_declaration_colon_expression_roundbracketclose_controlstructurebody_292(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_for_roundbracketopen_declaration_colon_expression_roundbracketclose_controlstructurebody_292(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ifbody_293(bool is_can, std::shared_ptr<leaf::parsing::instance::if_else>& actual, leaf::parsing::instance::if_else_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_if_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_if_body(depth + 1);
    actual->if_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_elsebody_294(bool is_can, std::shared_ptr<leaf::parsing::instance::if_else>& actual, leaf::parsing::instance::if_else_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_else_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_else_body(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_elsebody_295(bool is_can, std::shared_ptr<leaf::parsing::instance::if_else>& actual, leaf::parsing::instance::if_else_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_else_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_else_body(depth + 1);
    actual->else_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if296_297(bool is_can, std::shared_ptr<leaf::parsing::instance::if_else>& actual, leaf::parsing::instance::if_else_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_elsebody_294(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_elsebody_295(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: else-body (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_elsebody_295(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: else-body (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::p_can_if_else(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::if_else> fake;
    if_else_state state;
    if (!m_ifbody_293(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if296_297(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::if_else> leaf::parsing::instance::p_match_if_else(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::if_else>();
    std::shared_ptr<leaf::parsing::instance::if_else> fake;
    if_else_state state;
    resettable resettable2(*this);
    if (m_ifbody_293(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_ifbody_293(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if296_297(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if296_297(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_case_expvalue_colon_controlstructurebody_298(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_case>& actual, leaf::parsing::instance::switch_case_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__case(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_value(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__colon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_control_structure_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__case(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_exp_value(depth + 1);
    actual->value = val8;
    skip();
    auto l10 = token__colon(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    auto val11 = p_match_control_structure_body(depth + 1);
    actual->body = val11;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_switch_case(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::switch_case> fake;
    switch_case_state state;
    if (!m_case_expvalue_colon_controlstructurebody_298(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::switch_case> leaf::parsing::instance::p_match_switch_case(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::switch_case>();
    std::shared_ptr<leaf::parsing::instance::switch_case> fake;
    switch_case_state state;
    resettable resettable2(*this);
    if (m_case_expvalue_colon_controlstructurebody_298(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_case_expvalue_colon_controlstructurebody_298(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_switch_roundbracketopen_expression_roundbracketclose_299(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__switch(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__round_bracket_close(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__switch(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto l11 = token__round_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto val12 = p_match_expression(depth + 1);
    actual->value = val12;
    skip();
    auto l14 = token__round_bracket_close(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketclose_300(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_switchcase_301(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_switch_case(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_switch_case(depth + 1);
    actual->part.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::if302_303(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = state.has_default.value();
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            report(" Multiple default cases found", depth);
            return true;
        }
        else
        {
            if (!is_can)
            {
                state.has_default = true;
            }
            return true;
        }
    }
    else
    {
        if (cond2)
        {
            report(" Multiple default cases found", depth);
            return true;
        }
        else
        {
            if (!is_can)
            {
                state.has_default = true;
            }
            return true;
        }
    }
}
bool leaf::parsing::instance::m_default_colon_controlstructurebody_304(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__default(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__colon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_control_structure_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__default(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto l9 = token__colon(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto val10 = p_match_control_structure_body(depth + 1);
    actual->default_body.push_back(val10);
    skip();
    if302_303(false, actual, state, depth + 1);
    return true;
}
bool leaf::parsing::instance::m_pragma_305(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma(depth + 1);
    actual->pragmas.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives306(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_switchcase_301(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_switchcase_301(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_default_colon_controlstructurebody_304(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_default_colon_controlstructurebody_304(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_pragma_305(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragma_305(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { switch-case, default, :, control-structure-body, pragma }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while307_308(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_curlybracketclose_300(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives306(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_300(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives306(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives306(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_300(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketclose_309(bool is_can, std::shared_ptr<leaf::parsing::instance::switch_>& actual, leaf::parsing::instance::switch__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_switch_(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::switch_> fake;
    switch__state state;
    if (!m_switch_roundbracketopen_expression_roundbracketclose_299(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while307_308(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketclose_309(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::switch_> leaf::parsing::instance::p_match_switch_(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::switch_>();
    std::shared_ptr<leaf::parsing::instance::switch_> fake;
    switch__state state;
    resettable resettable2(*this);
    resettable resettable3(*this);
    if (m_switch_roundbracketopen_expression_roundbracketclose_299(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_switch_roundbracketopen_expression_roundbracketclose_299(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (while307_308(true, fake, state, depth + 1))
    {
        resettable4.reset();
        while307_308(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_curlybracketclose_309(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_curlybracketclose_309(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_eol_310(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly_terminate>& actual, leaf::parsing::instance::assembly_terminate_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__eol(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__eol(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketclose_311(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly_terminate>& actual, leaf::parsing::instance::assembly_terminate_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives312(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly_terminate>& actual, leaf::parsing::instance::assembly_terminate_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_eol_310(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_eol_310(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_curlybracketclose_311(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_curlybracketclose_311(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_assembly_terminate(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::assembly_terminate> fake;
    assembly_terminate_state state;
    if (!alternatives312(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::assembly_terminate> leaf::parsing::instance::p_match_assembly_terminate(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::assembly_terminate>();
    std::shared_ptr<leaf::parsing::instance::assembly_terminate> fake;
    assembly_terminate_state state;
    resettable resettable2(*this);
    if (alternatives312(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives312(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_assembly_curlybracketopen_313(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__assembly(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__curly_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__assembly(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto l9 = token__curly_bracket_open(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketclose_314(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_assemblyterminate_315(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_assembly_terminate(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_assembly_terminate(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_scalar_316(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_scalar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_scalar(depth + 1).value(), tok::SCALAR);
    actual->args.push_back(val4);
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerbinary_317(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_binary(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_binary(depth + 1).value(), tok::INTEGER_BINARY);
    actual->args.push_back(val4);
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerhex_318(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_hex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_hex(depth + 1).value(), tok::INTEGER_HEX);
    actual->args.push_back(val4);
    skip();
    return true;
}
bool leaf::parsing::instance::m_integer_319(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer(depth + 1).value(), tok::INTEGER);
    actual->args.push_back(val4);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives320(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_scalar_316(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scalar_316(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerbinary_317(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerbinary_317(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerhex_318(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerhex_318(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integer_319(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integer_319(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while321_322(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_assemblyterminate_315(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            alternatives320(true, actual, state, depth + 1);
            resettable resettable2(*this);
            cond3 = m_assemblyterminate_315(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            alternatives320(false, actual, state, depth + 1);
            resettable resettable2(*this);
            cond3 = m_assemblyterminate_315(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_ident_323(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->opcode.push_back(val4);
    skip();
    while321_322(false, actual, state, depth + 1);
    return true;
}
bool leaf::parsing::instance::while324_325(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_curlybracketclose_314(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            if (m_ident_323(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: ident ({ Token: ident}) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_314(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (m_ident_323(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: ident ({ Token: ident}) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_314(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketclose_326(bool is_can, std::shared_ptr<leaf::parsing::instance::assembly>& actual, leaf::parsing::instance::assembly_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_assembly(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::assembly> fake;
    assembly_state state;
    if (!m_assembly_curlybracketopen_313(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while324_325(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketclose_326(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::assembly> leaf::parsing::instance::p_match_assembly(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::assembly>();
    std::shared_ptr<leaf::parsing::instance::assembly> fake;
    assembly_state state;
    resettable resettable2(*this);
    if (m_assembly_curlybracketopen_313(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_assembly_curlybracketopen_313(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (while324_325(true, fake, state, depth + 1))
    {
        resettable3.reset();
        while324_325(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_curlybracketclose_326(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_curlybracketclose_326(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_pragma_327(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma(depth + 1);
    actual->pragmas = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_whileloop_328(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_while_loop(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_while_loop(depth + 1);
    actual->content = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_forbody_329(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_for_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_for_body(depth + 1);
    actual->content = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_foreachbody_330(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_for_each_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_for_each_body(depth + 1);
    actual->content = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ifelse_331(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_if_else(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_if_else(depth + 1);
    actual->content = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_switch_332(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_switch_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_switch_(depth + 1);
    actual->content = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_scope_333(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_scope(depth + 1);
    actual->content = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_assembly_334(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_assembly(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_assembly(depth + 1);
    actual->content = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives335(bool is_can, std::shared_ptr<leaf::parsing::instance::control_structure>& actual, leaf::parsing::instance::control_structure_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_pragma_327(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragma_327(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_whileloop_328(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_whileloop_328(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_forbody_329(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_forbody_329(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_foreachbody_330(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_foreachbody_330(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ifelse_331(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ifelse_331(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_switch_332(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_switch_332(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_scope_333(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scope_333(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_assembly_334(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_assembly_334(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_control_structure(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::control_structure> fake;
    control_structure_state state;
    if (!alternatives335(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::control_structure> leaf::parsing::instance::p_match_control_structure(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::control_structure>();
    std::shared_ptr<leaf::parsing::instance::control_structure> fake;
    control_structure_state state;
    resettable resettable2(*this);
    if (alternatives335(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives335(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_alloc_336(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain_start>& actual, leaf::parsing::instance::exp_chain_start_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_alloc(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_alloc(depth + 1);
    actual->part_alloc = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_free_337(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain_start>& actual, leaf::parsing::instance::exp_chain_start_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_free(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_free(depth + 1);
    actual->part_free = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_call_338(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain_start>& actual, leaf::parsing::instance::exp_chain_start_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_call(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_call(depth + 1);
    actual->part_call = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_339(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain_start>& actual, leaf::parsing::instance::exp_chain_start_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->part_ident = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives340(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain_start>& actual, leaf::parsing::instance::exp_chain_start_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_alloc_336(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_alloc_336(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_free_337(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_free_337(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_call_338(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_call_338(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_339(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_339(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_exp_chain_start(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_chain_start> fake;
    exp_chain_start_state state;
    if (!alternatives340(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::exp_chain_start> leaf::parsing::instance::p_match_exp_chain_start(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_chain_start>();
    std::shared_ptr<leaf::parsing::instance::exp_chain_start> fake;
    exp_chain_start_state state;
    resettable resettable2(*this);
    if (alternatives340(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives340(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typeof_341(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_typeof_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_typeof_(depth + 1);
    actual->typeof_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_nameof_342(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_nameof(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_nameof(depth + 1);
    actual->nameof = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_sizeof_343(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_sizeof_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_sizeof_(depth + 1);
    actual->sizeof_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_scalar_344(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_scalar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_scalar(depth + 1).value(), tok::SCALAR);
    actual->t = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_false_345(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_false_(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_false_(depth + 1).value(), tok::FALSE_);
    actual->t = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_true_346(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_true_(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_true_(depth + 1).value(), tok::TRUE_);
    actual->t = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerhex_347(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_hex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_hex(depth + 1).value(), tok::INTEGER_HEX);
    actual->t = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerbinary_348(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_binary(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_binary(depth + 1).value(), tok::INTEGER_BINARY);
    actual->t = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integer_349(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer(depth + 1).value(), tok::INTEGER);
    actual->t = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_string_350(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_string(depth + 1).value(), tok::STRING);
    actual->t = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_char_351(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_char_(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_char_(depth + 1).value(), tok::CHAR_);
    actual->t = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives352(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_constant>& actual, leaf::parsing::instance::exp_constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_typeof_341(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typeof_341(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_nameof_342(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_nameof_342(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_sizeof_343(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_sizeof_343(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_scalar_344(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scalar_344(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_false_345(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_false_345(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_true_346(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_true_346(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerhex_347(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerhex_347(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerbinary_348(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerbinary_348(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integer_349(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integer_349(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_string_350(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_string_350(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_char_351(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_char_351(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_exp_constant(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_constant> fake;
    exp_constant_state state;
    if (!alternatives352(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::exp_constant> leaf::parsing::instance::p_match_exp_constant(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_constant>();
    std::shared_ptr<leaf::parsing::instance::exp_constant> fake;
    exp_constant_state state;
    resettable resettable2(*this);
    if (alternatives352(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives352(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_capturelist_methodarglist_scopelambda_353(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_lambda>& actual, leaf::parsing::instance::exp_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_capture_list(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_method_arglist(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope_lambda(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_capture_list(depth + 1);
    actual->capture = val2;
    skip();
    auto val3 = p_match_method_arglist(depth + 1);
    actual->args = val3;
    skip();
    auto val4 = p_match_scope_lambda(depth + 1);
    actual->scope = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_methodarglist_scopelambda_354(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_lambda>& actual, leaf::parsing::instance::exp_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope_lambda(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_arglist(depth + 1);
    actual->args = val2;
    skip();
    auto val3 = p_match_scope_lambda(depth + 1);
    actual->scope = val3;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives355(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_lambda>& actual, leaf::parsing::instance::exp_lambda_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_capturelist_methodarglist_scopelambda_353(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_capturelist_methodarglist_scopelambda_353(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_methodarglist_scopelambda_354(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_methodarglist_scopelambda_354(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_exp_lambda(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_lambda> fake;
    exp_lambda_state state;
    if (!alternatives355(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::exp_lambda> leaf::parsing::instance::p_match_exp_lambda(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_lambda>();
    std::shared_ptr<leaf::parsing::instance::exp_lambda> fake;
    exp_lambda_state state;
    resettable resettable2(*this);
    if (alternatives355(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives355(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_copy_356(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list_item>& actual, leaf::parsing::instance::capture_list_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__copy(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__copy(depth + 1).value(), tok::_COPY);
    actual->capture_type = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives357(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list_item>& actual, leaf::parsing::instance::capture_list_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_copy_356(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_copy_356(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_ident_358(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list_item>& actual, leaf::parsing::instance::capture_list_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->variable = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_capture_list_item(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::capture_list_item> fake;
    capture_list_item_state state;
    if (!alternatives357(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_ident_358(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::capture_list_item> leaf::parsing::instance::p_match_capture_list_item(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::capture_list_item>();
    std::shared_ptr<leaf::parsing::instance::capture_list_item> fake;
    capture_list_item_state state;
    resettable resettable2(*this);
    if (alternatives357(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives357(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_ident_358(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_ident_358(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_squarebracketopen_359(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_capturelistitem_360(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_capture_list_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_capture_list_item(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_capturelistitem_361(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_capture_list_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_capture_list_item(depth + 1);
    actual->items.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_capturelistitem_362(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_capture_list_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_capture_list_item(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_capturelistitem_363(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_capture_list_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_capture_list_item(depth + 1);
    actual->items.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::while364_365(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_capturelistitem_362(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_comma_capturelistitem_363(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}), $ref: capture-list-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_capturelistitem_362(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_comma_capturelistitem_363(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}), $ref: capture-list-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_capturelistitem_362(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_comma_366(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_367(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if368_369(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_comma_366(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_comma_367(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_comma_367(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::if370_371(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_capturelistitem_360(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_capturelistitem_361(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: capture-list-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            while364_365(true, actual, state, depth + 1);
            if368_369(true, actual, state, depth + 1);
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_capturelistitem_361(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: capture-list-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            while364_365(false, actual, state, depth + 1);
            if368_369(false, actual, state, depth + 1);
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_squarebracketclose_372(bool is_can, std::shared_ptr<leaf::parsing::instance::capture_list>& actual, leaf::parsing::instance::capture_list_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_capture_list(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::capture_list> fake;
    capture_list_state state;
    if (!m_squarebracketopen_359(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if370_371(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_squarebracketclose_372(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::capture_list> leaf::parsing::instance::p_match_capture_list(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::capture_list>();
    std::shared_ptr<leaf::parsing::instance::capture_list> fake;
    capture_list_state state;
    resettable resettable2(*this);
    if (m_squarebracketopen_359(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_squarebracketopen_359(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if370_371(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if370_371(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_squarebracketclose_372(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_squarebracketclose_372(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_explambda_373(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_exp_lambda(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_exp_lambda(depth + 1);
    actual->exp_lambda = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expconstant_374(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_exp_constant(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_exp_constant(depth + 1);
    actual->exp_constant = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_scalarliteral_375(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_scalar_literal(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_scalar_literal(depth + 1);
    actual->scalar = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerhexliteral_376(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_integer_hex_literal(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_integer_hex_literal(depth + 1);
    actual->integer_hex = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerbinaryliteral_377(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_integer_binary_literal(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_integer_binary_literal(depth + 1);
    actual->integer_binary = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerliteral_378(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_integer_literal(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_integer_literal(depth + 1);
    actual->integer = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_charliteral_379(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_char_literal(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_char_literal(depth + 1);
    actual->character = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_stringliteral_380(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_string_literal(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_string_literal(depth + 1);
    actual->string = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expconstant_381(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_exp_constant(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_exp_constant(depth + 1);
    actual->constant = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives382(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_value>& actual, leaf::parsing::instance::exp_value_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_explambda_373(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_explambda_373(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_expconstant_374(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_expconstant_374(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_scalarliteral_375(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scalarliteral_375(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerhexliteral_376(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerhexliteral_376(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerbinaryliteral_377(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerbinaryliteral_377(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerliteral_378(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerliteral_378(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_charliteral_379(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_charliteral_379(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_stringliteral_380(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_stringliteral_380(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_expconstant_381(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_expconstant_381(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_exp_value(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_value> fake;
    exp_value_state state;
    if (!alternatives382(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::exp_value> leaf::parsing::instance::p_match_exp_value(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_value>();
    std::shared_ptr<leaf::parsing::instance::exp_value> fake;
    exp_value_state state;
    resettable resettable2(*this);
    if (alternatives382(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives382(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_roundbracketopen_expression_roundbracketclose_383(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_nullar>& actual, leaf::parsing::instance::exp_nullar_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__round_bracket_open(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_expression(depth + 1);
    actual->value = val8;
    skip();
    auto l10 = token__round_bracket_close(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_expchain_384(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_nullar>& actual, leaf::parsing::instance::exp_nullar_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_chain(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_chain(depth + 1);
    actual->value = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expvalue_385(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_nullar>& actual, leaf::parsing::instance::exp_nullar_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_exp_value(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_exp_value(depth + 1);
    actual->value = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives386(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_nullar>& actual, leaf::parsing::instance::exp_nullar_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_roundbracketopen_expression_roundbracketclose_383(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_roundbracketopen_expression_roundbracketclose_383(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_expchain_384(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_expchain_384(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_expvalue_385(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_expvalue_385(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_exp_nullar(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_nullar> fake;
    exp_nullar_state state;
    if (!alternatives386(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::exp_nullar> leaf::parsing::instance::p_match_exp_nullar(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_nullar>();
    std::shared_ptr<leaf::parsing::instance::exp_nullar> fake;
    exp_nullar_state state;
    resettable resettable2(*this);
    if (alternatives386(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives386(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_exclamation_expunary_387(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_unary>& actual, leaf::parsing::instance::exp_unary_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__exclamation(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__exclamation(depth + 1).value(), tok::_EXCLAMATION);
    actual->operator_ = val4;
    skip();
    auto val5 = p_match_exp_unary(depth + 1);
    actual->value = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_tilde_expunary_388(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_unary>& actual, leaf::parsing::instance::exp_unary_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__tilde(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__tilde(depth + 1).value(), tok::_TILDE);
    actual->operator_ = val4;
    skip();
    auto val5 = p_match_exp_unary(depth + 1);
    actual->value = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_minus_expunary_389(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_unary>& actual, leaf::parsing::instance::exp_unary_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_minus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_minus(depth + 1).value(), tok::MINUS);
    actual->operator_ = val4;
    skip();
    auto val5 = p_match_exp_unary(depth + 1);
    actual->value = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_plus_expunary_390(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_unary>& actual, leaf::parsing::instance::exp_unary_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_plus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_plus(depth + 1).value(), tok::PLUS);
    actual->operator_ = val4;
    skip();
    auto val5 = p_match_exp_unary(depth + 1);
    actual->value = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_roundbracketopen_typematch_roundbracketclose_expunary_391(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_unary>& actual, leaf::parsing::instance::exp_unary_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__round_bracket_open(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_type_match(depth + 1);
    actual->cast_target = val8;
    skip();
    auto l10 = token__round_bracket_close(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    auto val11 = p_match_exp_unary(depth + 1);
    actual->value = val11;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expnullar_392(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_unary>& actual, leaf::parsing::instance::exp_unary_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_exp_nullar(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_exp_nullar(depth + 1);
    actual->value = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives393(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_unary>& actual, leaf::parsing::instance::exp_unary_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_exclamation_expunary_387(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_exclamation_expunary_387(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_tilde_expunary_388(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_tilde_expunary_388(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_minus_expunary_389(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_minus_expunary_389(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_plus_expunary_390(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_plus_expunary_390(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_roundbracketopen_typematch_roundbracketclose_expunary_391(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_roundbracketopen_typematch_roundbracketclose_expunary_391(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_expnullar_392(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_expnullar_392(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_exp_unary(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_unary> fake;
    exp_unary_state state;
    if (!alternatives393(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::exp_unary> leaf::parsing::instance::p_match_exp_unary(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_unary>();
    std::shared_ptr<leaf::parsing::instance::exp_unary> fake;
    exp_unary_state state;
    resettable resettable2(*this);
    if (alternatives393(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives393(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_expor_equal_expression_394(bool is_can, std::shared_ptr<leaf::parsing::instance::expression>& actual, leaf::parsing::instance::expression_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_or(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = lr_match_exp_or(depth + 1);
    actual->assign_to = val4;
    skip();
    auto l6 = token__equal(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    auto val7 = p_match_expression(depth + 1);
    actual->value = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expor_395(bool is_can, std::shared_ptr<leaf::parsing::instance::expression>& actual, leaf::parsing::instance::expression_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_or(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_or(depth + 1);
    actual->exp = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_expression(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::expression> fake;
    expression_state state;
    if (!m_expor_equal_expression_394(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_expor_395(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::expression> leaf::parsing::instance::p_match_expression(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::expression>();
    std::shared_ptr<leaf::parsing::instance::expression> fake;
    expression_state state;
    resettable resettable2(*this);
    if (m_expor_equal_expression_394(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_expor_equal_expression_394(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_expor_395(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_expor_395(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_public_396(bool is_can, std::shared_ptr<leaf::parsing::instance::encapsulation>& actual, leaf::parsing::instance::encapsulation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__public(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__public(depth + 1).value(), tok::_PUBLIC);
    actual->tok = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_local_397(bool is_can, std::shared_ptr<leaf::parsing::instance::encapsulation>& actual, leaf::parsing::instance::encapsulation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__local(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__local(depth + 1).value(), tok::_LOCAL);
    actual->tok = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_derived_398(bool is_can, std::shared_ptr<leaf::parsing::instance::encapsulation>& actual, leaf::parsing::instance::encapsulation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__derived(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__derived(depth + 1).value(), tok::_DERIVED);
    actual->tok = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_private_399(bool is_can, std::shared_ptr<leaf::parsing::instance::encapsulation>& actual, leaf::parsing::instance::encapsulation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__private(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__private(depth + 1).value(), tok::_PRIVATE);
    actual->tok = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives400(bool is_can, std::shared_ptr<leaf::parsing::instance::encapsulation>& actual, leaf::parsing::instance::encapsulation_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_public_396(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_public_396(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_local_397(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_local_397(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_derived_398(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_derived_398(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_private_399(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_private_399(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_encapsulation(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::encapsulation> fake;
    encapsulation_state state;
    if (!alternatives400(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::encapsulation> leaf::parsing::instance::p_match_encapsulation(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::encapsulation>();
    std::shared_ptr<leaf::parsing::instance::encapsulation> fake;
    encapsulation_state state;
    resettable resettable2(*this);
    if (alternatives400(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives400(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_401(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_402(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while403_404(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_401(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_402(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_401(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_402(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_401(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_namespace_identnavigation_405(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__namespace(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_ident_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__namespace(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = lr_match_ident_navigation(depth + 1);
    actual->name = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketopen_406(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketclose_407(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_contract_408(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_contract(depth + 1);
    actual->contracts.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_aliasencapsulated_409(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_alias_encapsulated(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_alias_encapsulated(depth + 1);
    actual->aliases.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_constant_410(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_constant(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_constant(depth + 1);
    actual->constants.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_using_411(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_using_(depth + 1);
    actual->usings.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_namespace_412(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_namespace_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_namespace_(depth + 1);
    actual->namespaces.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_conversion_413(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_conversion(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_conversion(depth + 1);
    actual->conversions.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_class_414(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_class_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_class_(depth + 1);
    actual->classes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_method_415(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method(depth + 1);
    actual->methods.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_property_416(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_property(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_property(depth + 1);
    actual->properties.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_field_417(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_field(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_field(depth + 1);
    actual->fields.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_pragma_418(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma(depth + 1);
    actual->pragmas.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives419(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_contract_408(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contract_408(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_aliasencapsulated_409(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_aliasencapsulated_409(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_constant_410(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_constant_410(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_using_411(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_using_411(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_namespace_412(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_namespace_412(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_conversion_413(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_conversion_413(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_class_414(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_class_414(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_method_415(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_method_415(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_property_416(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_property_416(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_field_417(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_field_417(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_pragma_418(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragma_418(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { contract, alias-encapsulated, constant, using, namespace, conversion, class, method, property, field, pragma }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while420_421(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_curlybracketclose_407(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives419(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_407(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives419(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives419(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_407(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketclose_422(bool is_can, std::shared_ptr<leaf::parsing::instance::namespace_>& actual, leaf::parsing::instance::namespace__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_namespace_(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::namespace_> fake;
    namespace__state state;
    if (!while403_404(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_namespace_identnavigation_405(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketopen_406(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while420_421(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketclose_422(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::namespace_> leaf::parsing::instance::p_match_namespace_(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::namespace_>();
    std::shared_ptr<leaf::parsing::instance::namespace_> fake;
    namespace__state state;
    resettable resettable2(*this);
    if (while403_404(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while403_404(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_namespace_identnavigation_405(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_namespace_identnavigation_405(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_curlybracketopen_406(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_curlybracketopen_406(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (while420_421(true, fake, state, depth + 1))
    {
        resettable5.reset();
        while420_421(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (m_curlybracketclose_422(true, fake, state, depth + 1))
    {
        resettable6.reset();
        m_curlybracketclose_422(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_423(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_424(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while425_426(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_423(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_424(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_423(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_424(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_423(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_encapsulation_class_ident_427(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_encapsulation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__class(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_encapsulation(depth + 1);
    actual->scope = val6;
    skip();
    auto l8 = token__class(depth + 1).value();
    for (;l8 != 0; l8--)
    {
        next();
    }
    skip();
    auto val9 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val9;
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_428(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_429(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if430_431(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_428(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_429(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_429(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_lifetime_432(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_lifetime(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_lifetime(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_lifetime_433(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_lifetime(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_lifetime(depth + 1);
    actual->lifetime = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if434_435(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_lifetime_432(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_lifetime_433(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: lifetime (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_lifetime_433(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: lifetime (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketopen_436(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_curlybracketclose_437(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_contract_438(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_contract(depth + 1);
    actual->contracts.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_aliasencapsulated_439(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_alias_encapsulated(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_alias_encapsulated(depth + 1);
    actual->aliases.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_constant_440(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_constant(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_constant(depth + 1);
    actual->constants.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_using_441(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_using_(depth + 1);
    actual->usings.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_indexer_442(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_indexer(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_indexer(depth + 1);
    actual->indexers.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_operatorbinaryoverload_443(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_operator_binary_overload(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_operator_binary_overload(depth + 1);
    actual->operators_binary.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_operatorunaryoverload_444(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_operator_unary_overload(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_operator_unary_overload(depth + 1);
    actual->operators_unary.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_operatornullaroverload_445(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_operator_nullar_overload(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_operator_nullar_overload(depth + 1);
    actual->operators_nullar.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_conversion_446(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_conversion(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_conversion(depth + 1);
    actual->conversions.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_class_447(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_class_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_class_(depth + 1);
    actual->classes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_constructor_448(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_constructor(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_constructor(depth + 1);
    actual->constructors.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_destructor_449(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_destructor(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_destructor(depth + 1);
    actual->destructors.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_copystructor_450(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_copystructor(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_copystructor(depth + 1);
    actual->copystructors.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_property_451(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_property(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_property(depth + 1);
    actual->properties.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_field_452(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_field(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_field(depth + 1);
    actual->fields.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_method_453(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method(depth + 1);
    actual->methods.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_pragma_454(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma(depth + 1);
    actual->pragmas.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives455(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_contract_438(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contract_438(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_aliasencapsulated_439(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_aliasencapsulated_439(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_constant_440(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_constant_440(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_using_441(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_using_441(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_indexer_442(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_indexer_442(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_operatorbinaryoverload_443(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_operatorbinaryoverload_443(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_operatorunaryoverload_444(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_operatorunaryoverload_444(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_operatornullaroverload_445(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_operatornullaroverload_445(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_conversion_446(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_conversion_446(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_class_447(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_class_447(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_constructor_448(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_constructor_448(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_destructor_449(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_destructor_449(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_copystructor_450(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_copystructor_450(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_property_451(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_property_451(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_field_452(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_field_452(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_method_453(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_method_453(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_pragma_454(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragma_454(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { contract, alias-encapsulated, constant, using, indexer, operator-binary-overload, operator-unary-overload, operator-nullar-overload, conversion, class, constructor, destructor, copystructor, property, field, method, pragma }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while456_457(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_curlybracketclose_437(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives455(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_437(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives455(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives455(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_curlybracketclose_437(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_curlybracketclose_458(bool is_can, std::shared_ptr<leaf::parsing::instance::class_>& actual, leaf::parsing::instance::class__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__curly_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__curly_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_class_(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::class_> fake;
    class__state state;
    if (!while425_426(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_encapsulation_class_ident_427(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if430_431(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if434_435(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketopen_436(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while456_457(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_curlybracketclose_458(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::class_> leaf::parsing::instance::p_match_class_(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::class_>();
    std::shared_ptr<leaf::parsing::instance::class_> fake;
    class__state state;
    resettable resettable2(*this);
    if (while425_426(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while425_426(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_encapsulation_class_ident_427(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_encapsulation_class_ident_427(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if430_431(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if430_431(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (if434_435(true, fake, state, depth + 1))
    {
        resettable5.reset();
        if434_435(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (m_curlybracketopen_436(true, fake, state, depth + 1))
    {
        resettable6.reset();
        m_curlybracketopen_436(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable7(*this);
    if (while456_457(true, fake, state, depth + 1))
    {
        resettable7.reset();
        while456_457(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable8(*this);
    if (m_curlybracketclose_458(true, fake, state, depth + 1))
    {
        resettable8.reset();
        m_curlybracketclose_458(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_459(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_item>& actual, leaf::parsing::instance::method_arglist_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_460(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_item>& actual, leaf::parsing::instance::method_arglist_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while461_462(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_item>& actual, leaf::parsing::instance::method_arglist_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_459(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_460(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_459(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_460(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_459(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_typematch_ident_463(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_item>& actual, leaf::parsing::instance::method_arglist_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_type_match(depth + 1);
    actual->type = val4;
    skip();
    auto val5 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_method_arglist_item(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::method_arglist_item> fake;
    method_arglist_item_state state;
    if (!while461_462(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_typematch_ident_463(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::method_arglist_item> leaf::parsing::instance::p_match_method_arglist_item(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::method_arglist_item>();
    std::shared_ptr<leaf::parsing::instance::method_arglist_item> fake;
    method_arglist_item_state state;
    resettable resettable2(*this);
    if (while461_462(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while461_462(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_typematch_ident_463(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_typematch_ident_463(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_roundbracketopen_464(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_methodarglistitem_465(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_method_arglist_item(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_methodarglistitem_466(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_arglist_item(depth + 1);
    actual->args.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_roundbracketclose_467(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_methodarglistitem_468(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_method_arglist_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_method_arglist_item(depth + 1);
    actual->args.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives469(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_comma_methodarglistitem_468(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_methodarglistitem_468(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { ,, method-arglist-item }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while470_471(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_roundbracketclose_467(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives469(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_roundbracketclose_467(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives469(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives469(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_roundbracketclose_467(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_comma_472(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_473(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if474_475(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_comma_472(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_comma_473(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_comma_473(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::if476_477(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_methodarglistitem_465(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_methodarglistitem_466(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: method-arglist-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            while470_471(true, actual, state, depth + 1);
            if474_475(true, actual, state, depth + 1);
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_methodarglistitem_466(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: method-arglist-item (XCG.Parsing.Production) }", depth);
                return false;
            }
            while470_471(false, actual, state, depth + 1);
            if474_475(false, actual, state, depth + 1);
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_roundbracketclose_478(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist>& actual, leaf::parsing::instance::method_arglist_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_method_arglist(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::method_arglist> fake;
    method_arglist_state state;
    if (!m_roundbracketopen_464(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if476_477(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketclose_478(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::method_arglist> leaf::parsing::instance::p_match_method_arglist(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::method_arglist>();
    std::shared_ptr<leaf::parsing::instance::method_arglist> fake;
    method_arglist_state state;
    resettable resettable2(*this);
    if (m_roundbracketopen_464(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_roundbracketopen_464(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if476_477(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if476_477(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_roundbracketclose_478(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_roundbracketclose_478(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_squarebracketopen_479(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_methodarglistitem_480(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_arglist_item(depth + 1);
    actual->args.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_squarebracketclose_481(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_methodarglistitem_482(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_method_arglist_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_method_arglist_item(depth + 1);
    actual->args.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives483(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_comma_methodarglistitem_482(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_methodarglistitem_482(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { ,, method-arglist-item }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while484_485(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_squarebracketclose_481(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives483(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_squarebracketclose_481(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives483(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives483(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_squarebracketclose_481(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_comma_486(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_487(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if488_489(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_comma_486(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_comma_487(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_comma_487(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: , ({ Token: , (,)}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_squarebracketclose_490(bool is_can, std::shared_ptr<leaf::parsing::instance::method_arglist_indexer>& actual, leaf::parsing::instance::method_arglist_indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__square_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_method_arglist_indexer(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::method_arglist_indexer> fake;
    method_arglist_indexer_state state;
    if (!m_squarebracketopen_479(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodarglistitem_480(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while484_485(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if488_489(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_squarebracketclose_490(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::method_arglist_indexer> leaf::parsing::instance::p_match_method_arglist_indexer(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::method_arglist_indexer>();
    std::shared_ptr<leaf::parsing::instance::method_arglist_indexer> fake;
    method_arglist_indexer_state state;
    resettable resettable2(*this);
    if (m_squarebracketopen_479(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_squarebracketopen_479(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_methodarglistitem_480(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_methodarglistitem_480(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (while484_485(true, fake, state, depth + 1))
    {
        resettable4.reset();
        while484_485(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (if488_489(true, fake, state, depth + 1))
    {
        resettable5.reset();
        if488_489(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (m_squarebracketclose_490(true, fake, state, depth + 1))
    {
        resettable6.reset();
        m_squarebracketclose_490(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_encapsulation_491(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_encapsulation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_encapsulation(depth + 1);
    actual->encaps = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_sealed_492(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__sealed(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__sealed(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_sealed_493(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__sealed(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__sealed(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if494_495(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_sealed_492(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_sealed_493(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: sealed ({ Token: sealed (sealed)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_sealed = true;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_sealed_493(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: sealed ({ Token: sealed (sealed)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_sealed = true;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_virtual_496(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__virtual(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__virtual(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_virtual_497(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__virtual(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__virtual(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if498_499(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_virtual_496(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_virtual_497(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: virtual ({ Token: virtual (virtual)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_virtual = true;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_virtual_497(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: virtual ({ Token: virtual (virtual)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_virtual = true;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_unbound_500(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__unbound(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__unbound(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_unbound_501(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__unbound(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__unbound(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if502_503(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_unbound_500(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_unbound_501(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: unbound ({ Token: unbound (unbound)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_static = true;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_unbound_501(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: unbound ({ Token: unbound (unbound)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_static = true;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_inline_504(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__inline(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__inline(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_inline_505(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__inline(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__inline(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if506_507(bool is_can, std::shared_ptr<leaf::parsing::instance::method_meta>& actual, leaf::parsing::instance::method_meta_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_inline_504(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_inline_505(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: inline ({ Token: inline (inline)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_inline = true;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_inline_505(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: inline ({ Token: inline (inline)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_inline = true;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::p_can_method_meta(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::method_meta> fake;
    method_meta_state state;
    if (!m_encapsulation_491(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if494_495(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if498_499(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if502_503(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if506_507(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::method_meta> leaf::parsing::instance::p_match_method_meta(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::method_meta>();
    std::shared_ptr<leaf::parsing::instance::method_meta> fake;
    method_meta_state state;
    resettable resettable2(*this);
    if (m_encapsulation_491(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_encapsulation_491(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if494_495(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if494_495(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if498_499(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if498_499(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (if502_503(true, fake, state, depth + 1))
    {
        resettable5.reset();
        if502_503(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (if506_507(true, fake, state, depth + 1))
    {
        resettable6.reset();
        if506_507(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_508(bool is_can, std::shared_ptr<leaf::parsing::instance::method>& actual, leaf::parsing::instance::method_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_509(bool is_can, std::shared_ptr<leaf::parsing::instance::method>& actual, leaf::parsing::instance::method_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while510_511(bool is_can, std::shared_ptr<leaf::parsing::instance::method>& actual, leaf::parsing::instance::method_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_508(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_509(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_508(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_509(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_508(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodmeta_typematch_ident_512(bool is_can, std::shared_ptr<leaf::parsing::instance::method>& actual, leaf::parsing::instance::method_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_meta(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_method_meta(depth + 1);
    actual->meta = val4;
    skip();
    auto val5 = p_match_type_match(depth + 1);
    actual->return_type = val5;
    skip();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_513(bool is_can, std::shared_ptr<leaf::parsing::instance::method>& actual, leaf::parsing::instance::method_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_514(bool is_can, std::shared_ptr<leaf::parsing::instance::method>& actual, leaf::parsing::instance::method_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if515_516(bool is_can, std::shared_ptr<leaf::parsing::instance::method>& actual, leaf::parsing::instance::method_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_513(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_514(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_514(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodarglist_scope_517(bool is_can, std::shared_ptr<leaf::parsing::instance::method>& actual, leaf::parsing::instance::method_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_arglist(depth + 1);
    actual->arglist = val2;
    skip();
    auto val3 = p_match_scope(depth + 1);
    actual->body = val3;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_method(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::method> fake;
    method_state state;
    if (!while510_511(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodmeta_typematch_ident_512(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if515_516(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodarglist_scope_517(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::method> leaf::parsing::instance::p_match_method(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::method>();
    std::shared_ptr<leaf::parsing::instance::method> fake;
    method_state state;
    resettable resettable2(*this);
    if (while510_511(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while510_511(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_methodmeta_typematch_ident_512(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_methodmeta_typematch_ident_512(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if515_516(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if515_516(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_methodarglist_scope_517(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_methodarglist_scope_517(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_518(bool is_can, std::shared_ptr<leaf::parsing::instance::constructor>& actual, leaf::parsing::instance::constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_519(bool is_can, std::shared_ptr<leaf::parsing::instance::constructor>& actual, leaf::parsing::instance::constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while520_521(bool is_can, std::shared_ptr<leaf::parsing::instance::constructor>& actual, leaf::parsing::instance::constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_518(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_519(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_518(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_519(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_518(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_encapsulation_522(bool is_can, std::shared_ptr<leaf::parsing::instance::constructor>& actual, leaf::parsing::instance::constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_encapsulation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_encapsulation(depth + 1);
    actual->encaps = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_523(bool is_can, std::shared_ptr<leaf::parsing::instance::constructor>& actual, leaf::parsing::instance::constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_524(bool is_can, std::shared_ptr<leaf::parsing::instance::constructor>& actual, leaf::parsing::instance::constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if525_526(bool is_can, std::shared_ptr<leaf::parsing::instance::constructor>& actual, leaf::parsing::instance::constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_523(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_524(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_524(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodarglist_scope_527(bool is_can, std::shared_ptr<leaf::parsing::instance::constructor>& actual, leaf::parsing::instance::constructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_arglist(depth + 1);
    actual->arglist = val2;
    skip();
    auto val3 = p_match_scope(depth + 1);
    actual->body = val3;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_constructor(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::constructor> fake;
    constructor_state state;
    if (!while520_521(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_encapsulation_522(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if525_526(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodarglist_scope_527(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::constructor> leaf::parsing::instance::p_match_constructor(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::constructor>();
    std::shared_ptr<leaf::parsing::instance::constructor> fake;
    constructor_state state;
    resettable resettable2(*this);
    if (while520_521(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while520_521(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_encapsulation_522(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_encapsulation_522(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if525_526(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if525_526(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_methodarglist_scope_527(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_methodarglist_scope_527(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_528(bool is_can, std::shared_ptr<leaf::parsing::instance::destructor>& actual, leaf::parsing::instance::destructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_529(bool is_can, std::shared_ptr<leaf::parsing::instance::destructor>& actual, leaf::parsing::instance::destructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while530_531(bool is_can, std::shared_ptr<leaf::parsing::instance::destructor>& actual, leaf::parsing::instance::destructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_528(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_529(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_528(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_529(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_528(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_encapsulation_tilde_532(bool is_can, std::shared_ptr<leaf::parsing::instance::destructor>& actual, leaf::parsing::instance::destructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_encapsulation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__tilde(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_encapsulation(depth + 1);
    actual->encaps = val4;
    skip();
    auto l6 = token__tilde(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_533(bool is_can, std::shared_ptr<leaf::parsing::instance::destructor>& actual, leaf::parsing::instance::destructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_534(bool is_can, std::shared_ptr<leaf::parsing::instance::destructor>& actual, leaf::parsing::instance::destructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if535_536(bool is_can, std::shared_ptr<leaf::parsing::instance::destructor>& actual, leaf::parsing::instance::destructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_533(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_534(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_534(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodarglist_scope_537(bool is_can, std::shared_ptr<leaf::parsing::instance::destructor>& actual, leaf::parsing::instance::destructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_arglist(depth + 1);
    actual->arglist = val2;
    skip();
    auto val3 = p_match_scope(depth + 1);
    actual->body = val3;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_destructor(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::destructor> fake;
    destructor_state state;
    if (!while530_531(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_encapsulation_tilde_532(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if535_536(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodarglist_scope_537(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::destructor> leaf::parsing::instance::p_match_destructor(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::destructor>();
    std::shared_ptr<leaf::parsing::instance::destructor> fake;
    destructor_state state;
    resettable resettable2(*this);
    if (while530_531(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while530_531(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_encapsulation_tilde_532(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_encapsulation_tilde_532(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if535_536(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if535_536(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_methodarglist_scope_537(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_methodarglist_scope_537(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_538(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_539(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while540_541(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_538(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_539(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_538(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_539(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_538(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_encapsulation_plus_542(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_encapsulation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_plus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_encapsulation(depth + 1);
    actual->encaps = val4;
    skip();
    auto l6 = token_plus(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_543(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_544(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if545_546(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_543(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_544(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_544(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodarglist_547(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_arglist(depth + 1);
    actual->arglist = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_scope_548(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_scope(depth + 1);
    actual->body = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_equal_delete_549(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__delete(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__equal(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto l9 = token__delete(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives550(bool is_can, std::shared_ptr<leaf::parsing::instance::copystructor>& actual, leaf::parsing::instance::copystructor_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_scope_548(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scope_548(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_equal_delete_549(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_equal_delete_549(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_copystructor(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::copystructor> fake;
    copystructor_state state;
    if (!while540_541(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_encapsulation_plus_542(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if545_546(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodarglist_547(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives550(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::copystructor> leaf::parsing::instance::p_match_copystructor(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::copystructor>();
    std::shared_ptr<leaf::parsing::instance::copystructor> fake;
    copystructor_state state;
    resettable resettable2(*this);
    if (while540_541(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while540_541(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_encapsulation_plus_542(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_encapsulation_plus_542(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if545_546(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if545_546(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_methodarglist_547(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_methodarglist_547(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (alternatives550(true, fake, state, depth + 1))
    {
        resettable6.reset();
        alternatives550(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_551(bool is_can, std::shared_ptr<leaf::parsing::instance::conversion>& actual, leaf::parsing::instance::conversion_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_552(bool is_can, std::shared_ptr<leaf::parsing::instance::conversion>& actual, leaf::parsing::instance::conversion_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while553_554(bool is_can, std::shared_ptr<leaf::parsing::instance::conversion>& actual, leaf::parsing::instance::conversion_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_551(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_552(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_551(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_552(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_551(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodmeta_conversion_typematch_555(bool is_can, std::shared_ptr<leaf::parsing::instance::conversion>& actual, leaf::parsing::instance::conversion_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_meta(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__conversion(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_method_meta(depth + 1);
    actual->meta = val4;
    skip();
    auto l6 = token__conversion(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    auto val7 = p_match_type_match(depth + 1);
    actual->target_type = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_roundbracketopen_typematch_ident_roundbracketclose_556(bool is_can, std::shared_ptr<leaf::parsing::instance::conversion>& actual, leaf::parsing::instance::conversion_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__round_bracket_close(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__round_bracket_open(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto val10 = p_match_type_match(depth + 1);
    actual->source_type = val10;
    skip();
    auto val11 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val11;
    skip();
    auto l13 = token__round_bracket_close(depth + 1).value();
    for (;l13 != 0; l13--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_scope_557(bool is_can, std::shared_ptr<leaf::parsing::instance::conversion>& actual, leaf::parsing::instance::conversion_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_scope(depth + 1);
    actual->body = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_conversion(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::conversion> fake;
    conversion_state state;
    if (!while553_554(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodmeta_conversion_typematch_555(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketopen_typematch_ident_roundbracketclose_556(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_scope_557(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::conversion> leaf::parsing::instance::p_match_conversion(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::conversion>();
    std::shared_ptr<leaf::parsing::instance::conversion> fake;
    conversion_state state;
    resettable resettable2(*this);
    if (while553_554(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while553_554(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_methodmeta_conversion_typematch_555(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_methodmeta_conversion_typematch_555(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_roundbracketopen_typematch_ident_roundbracketclose_556(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_roundbracketopen_typematch_ident_roundbracketclose_556(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_scope_557(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_scope_557(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_558(bool is_can, std::shared_ptr<leaf::parsing::instance::indexer>& actual, leaf::parsing::instance::indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_559(bool is_can, std::shared_ptr<leaf::parsing::instance::indexer>& actual, leaf::parsing::instance::indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while560_561(bool is_can, std::shared_ptr<leaf::parsing::instance::indexer>& actual, leaf::parsing::instance::indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_558(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_559(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_558(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_559(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_558(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodmeta_typematch_562(bool is_can, std::shared_ptr<leaf::parsing::instance::indexer>& actual, leaf::parsing::instance::indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_meta(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_meta(depth + 1);
    actual->meta = val2;
    skip();
    auto val3 = p_match_type_match(depth + 1);
    actual->target_type = val3;
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_563(bool is_can, std::shared_ptr<leaf::parsing::instance::indexer>& actual, leaf::parsing::instance::indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_564(bool is_can, std::shared_ptr<leaf::parsing::instance::indexer>& actual, leaf::parsing::instance::indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if565_566(bool is_can, std::shared_ptr<leaf::parsing::instance::indexer>& actual, leaf::parsing::instance::indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_563(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_564(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_564(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodarglistindexer_scopegetset_567(bool is_can, std::shared_ptr<leaf::parsing::instance::indexer>& actual, leaf::parsing::instance::indexer_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_arglist_indexer(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope_getset(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method_arglist_indexer(depth + 1);
    actual->arglist = val2;
    skip();
    auto val3 = p_match_scope_getset(depth + 1);
    actual->body = val3;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_indexer(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::indexer> fake;
    indexer_state state;
    if (!while560_561(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodmeta_typematch_562(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if565_566(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodarglistindexer_scopegetset_567(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::indexer> leaf::parsing::instance::p_match_indexer(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::indexer>();
    std::shared_ptr<leaf::parsing::instance::indexer> fake;
    indexer_state state;
    resettable resettable2(*this);
    if (while560_561(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while560_561(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_methodmeta_typematch_562(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_methodmeta_typematch_562(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if565_566(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if565_566(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_methodarglistindexer_scopegetset_567(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_methodarglistindexer_scopegetset_567(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_568(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_569(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while570_571(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_568(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_569(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_568(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_569(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_568(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodmeta_typematch_operator_572(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_meta(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__operator(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_method_meta(depth + 1);
    actual->meta = val4;
    skip();
    auto val5 = p_match_type_match(depth + 1);
    actual->target_type = val5;
    skip();
    auto l7 = token__operator(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_573(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_574(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if575_576(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_573(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_574(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_574(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_roundbracketopen_methodarglistitem_roundbracketclose_577(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_method_arglist_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__round_bracket_open(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_method_arglist_item(depth + 1);
    actual->left = val8;
    skip();
    auto l10 = token__round_bracket_close(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_plus_578(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_plus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_plus(depth + 1).value(), tok::PLUS);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_minus_579(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_minus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_minus(depth + 1).value(), tok::MINUS);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_star_580(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_star(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_star(depth + 1).value(), tok::STAR);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_slash_581(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_slash(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_slash(depth + 1).value(), tok::SLASH);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_lessthenlessthenlessthen_582(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_less_then_less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_less_then_less_then(depth + 1).value(), tok::_LESS_THEN_LESS_THEN_LESS_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_lessthenlessthen_583(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_less_then(depth + 1).value(), tok::_LESS_THEN_LESS_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_lessthenequal_584(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_equal(depth + 1).value(), tok::_LESS_THEN_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_lessthen_585(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then(depth + 1).value(), tok::_LESS_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_greaterthengreaterthengreaterthen_586(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_greater_then_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_greater_then_greater_then(depth + 1).value(), tok::_GREATER_THEN_GREATER_THEN_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_greaterthengreaterthen_587(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_greater_then(depth + 1).value(), tok::_GREATER_THEN_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_greaterthenequal_588(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_equal(depth + 1).value(), tok::_GREATER_THEN_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_greaterthen_589(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then(depth + 1).value(), tok::_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_verticalbarverticalbar_590(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__vertical_bar_vertical_bar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__vertical_bar_vertical_bar(depth + 1).value(), tok::_VERTICAL_BAR_VERTICAL_BAR);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_verticalbar_591(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__vertical_bar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__vertical_bar(depth + 1).value(), tok::_VERTICAL_BAR);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ampersandampersand_592(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__ampersand_ampersand(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__ampersand_ampersand(depth + 1).value(), tok::_AMPERSAND_AMPERSAND);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ampersand_593(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__ampersand(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__ampersand(depth + 1).value(), tok::_AMPERSAND);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_equalequalequal_594(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal_equal_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__equal_equal_equal(depth + 1).value(), tok::_EQUAL_EQUAL_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_equalequal_595(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__equal_equal(depth + 1).value(), tok::_EQUAL_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_exclamationequal_596(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__exclamation_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__exclamation_equal(depth + 1).value(), tok::_EXCLAMATION_EQUAL);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_circumflex_597(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__circumflex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__circumflex(depth + 1).value(), tok::_CIRCUMFLEX);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives598(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_plus_578(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_plus_578(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_minus_579(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_minus_579(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_star_580(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_star_580(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_slash_581(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_slash_581(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_lessthenlessthenlessthen_582(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_lessthenlessthenlessthen_582(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_lessthenlessthen_583(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_lessthenlessthen_583(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_lessthenequal_584(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_lessthenequal_584(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_lessthen_585(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_lessthen_585(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_greaterthengreaterthengreaterthen_586(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_greaterthengreaterthengreaterthen_586(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_greaterthengreaterthen_587(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_greaterthengreaterthen_587(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_greaterthenequal_588(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_greaterthenequal_588(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_greaterthen_589(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_greaterthen_589(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_verticalbarverticalbar_590(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_verticalbarverticalbar_590(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_verticalbar_591(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_verticalbar_591(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ampersandampersand_592(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ampersandampersand_592(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ampersand_593(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ampersand_593(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_equalequalequal_594(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_equalequalequal_594(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_equalequal_595(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_equalequal_595(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_exclamationequal_596(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_exclamationequal_596(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_circumflex_597(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_circumflex_597(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_roundbracketopen_methodarglistitem_roundbracketclose_599(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_method_arglist_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__round_bracket_open(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_method_arglist_item(depth + 1);
    actual->right = val8;
    skip();
    auto l10 = token__round_bracket_close(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_scope_600(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_binary_overload>& actual, leaf::parsing::instance::operator_binary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_scope(depth + 1);
    actual->body = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_operator_binary_overload(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::operator_binary_overload> fake;
    operator_binary_overload_state state;
    if (!while570_571(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodmeta_typematch_operator_572(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if575_576(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketopen_methodarglistitem_roundbracketclose_577(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives598(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketopen_methodarglistitem_roundbracketclose_599(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_scope_600(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::operator_binary_overload> leaf::parsing::instance::p_match_operator_binary_overload(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::operator_binary_overload>();
    std::shared_ptr<leaf::parsing::instance::operator_binary_overload> fake;
    operator_binary_overload_state state;
    resettable resettable2(*this);
    if (while570_571(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while570_571(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_methodmeta_typematch_operator_572(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_methodmeta_typematch_operator_572(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if575_576(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if575_576(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_roundbracketopen_methodarglistitem_roundbracketclose_577(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_roundbracketopen_methodarglistitem_roundbracketclose_577(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (alternatives598(true, fake, state, depth + 1))
    {
        resettable6.reset();
        alternatives598(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable7(*this);
    if (m_roundbracketopen_methodarglistitem_roundbracketclose_599(true, fake, state, depth + 1))
    {
        resettable7.reset();
        m_roundbracketopen_methodarglistitem_roundbracketclose_599(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable8(*this);
    if (m_scope_600(true, fake, state, depth + 1))
    {
        resettable8.reset();
        m_scope_600(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_601(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_602(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while603_604(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_601(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_602(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_601(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_602(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_601(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodmeta_typematch_operator_605(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_meta(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__operator(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_method_meta(depth + 1);
    actual->meta = val4;
    skip();
    auto val5 = p_match_type_match(depth + 1);
    actual->target_type = val5;
    skip();
    auto l7 = token__operator(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_606(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_607(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if608_609(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_606(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_607(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_607(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_plus_610(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_plus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_plus(depth + 1).value(), tok::PLUS);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_minus_611(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_minus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_minus(depth + 1).value(), tok::MINUS);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_exclamation_612(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__exclamation(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__exclamation(depth + 1).value(), tok::_EXCLAMATION);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_tilde_613(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__tilde(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__tilde(depth + 1).value(), tok::_TILDE);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives614(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_plus_610(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_plus_610(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_minus_611(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_minus_611(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_exclamation_612(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_exclamation_612(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_tilde_613(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_tilde_613(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_roundbracketopen_methodarglistitem_roundbracketclose_615(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_method_arglist_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__round_bracket_open(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_method_arglist_item(depth + 1);
    actual->right = val8;
    skip();
    auto l10 = token__round_bracket_close(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_scope_616(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_unary_overload>& actual, leaf::parsing::instance::operator_unary_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_scope(depth + 1);
    actual->body = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_operator_unary_overload(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::operator_unary_overload> fake;
    operator_unary_overload_state state;
    if (!while603_604(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodmeta_typematch_operator_605(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if608_609(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives614(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketopen_methodarglistitem_roundbracketclose_615(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_scope_616(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::operator_unary_overload> leaf::parsing::instance::p_match_operator_unary_overload(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::operator_unary_overload>();
    std::shared_ptr<leaf::parsing::instance::operator_unary_overload> fake;
    operator_unary_overload_state state;
    resettable resettable2(*this);
    if (while603_604(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while603_604(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_methodmeta_typematch_operator_605(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_methodmeta_typematch_operator_605(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if608_609(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if608_609(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (alternatives614(true, fake, state, depth + 1))
    {
        resettable5.reset();
        alternatives614(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (m_roundbracketopen_methodarglistitem_roundbracketclose_615(true, fake, state, depth + 1))
    {
        resettable6.reset();
        m_roundbracketopen_methodarglistitem_roundbracketclose_615(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable7(*this);
    if (m_scope_616(true, fake, state, depth + 1))
    {
        resettable7.reset();
        m_scope_616(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_617(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_618(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while619_620(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_617(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_618(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_617(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_618(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_617(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodmeta_operator_621(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_meta(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__operator(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_method_meta(depth + 1);
    actual->meta = val4;
    skip();
    auto l6 = token__operator(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_622(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_template_definition(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinition_623(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::if624_625(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_templatedefinition_622(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_templatedefinition_623(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_templatedefinition_623(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: template-definition (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_dot_626(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__dot(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__dot(depth + 1).value(), tok::_DOT);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_minusgreaterthen_627(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__minus_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__minus_greater_then(depth + 1).value(), tok::_MINUS_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives628(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_dot_626(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_dot_626(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_minusgreaterthen_627(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_minusgreaterthen_627(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_scope_629(bool is_can, std::shared_ptr<leaf::parsing::instance::operator_nullar_overload>& actual, leaf::parsing::instance::operator_nullar_overload_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_scope(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_scope(depth + 1);
    actual->body = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_operator_nullar_overload(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::operator_nullar_overload> fake;
    operator_nullar_overload_state state;
    if (!while619_620(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodmeta_operator_621(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if624_625(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives628(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_scope_629(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::operator_nullar_overload> leaf::parsing::instance::p_match_operator_nullar_overload(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::operator_nullar_overload>();
    std::shared_ptr<leaf::parsing::instance::operator_nullar_overload> fake;
    operator_nullar_overload_state state;
    resettable resettable2(*this);
    if (while619_620(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while619_620(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_methodmeta_operator_621(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_methodmeta_operator_621(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if624_625(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if624_625(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (alternatives628(true, fake, state, depth + 1))
    {
        resettable5.reset();
        alternatives628(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable6(*this);
    if (m_scope_629(true, fake, state, depth + 1))
    {
        resettable6.reset();
        m_scope_629(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_630(bool is_can, std::shared_ptr<leaf::parsing::instance::property>& actual, leaf::parsing::instance::property_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_631(bool is_can, std::shared_ptr<leaf::parsing::instance::property>& actual, leaf::parsing::instance::property_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while632_633(bool is_can, std::shared_ptr<leaf::parsing::instance::property>& actual, leaf::parsing::instance::property_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_630(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_631(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_630(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_631(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_630(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_methodmeta_typematch_ident_scopegetset_634(bool is_can, std::shared_ptr<leaf::parsing::instance::property>& actual, leaf::parsing::instance::property_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method_meta(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_scope_getset(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_method_meta(depth + 1);
    actual->meta = val4;
    skip();
    auto val5 = p_match_type_match(depth + 1);
    actual->target_type = val5;
    skip();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val6;
    skip();
    auto val7 = p_match_scope_getset(depth + 1);
    actual->body = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_property(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::property> fake;
    property_state state;
    if (!while632_633(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_methodmeta_typematch_ident_scopegetset_634(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::property> leaf::parsing::instance::p_match_property(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::property>();
    std::shared_ptr<leaf::parsing::instance::property> fake;
    property_state state;
    resettable resettable2(*this);
    if (while632_633(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while632_633(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_methodmeta_typematch_ident_scopegetset_634(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_methodmeta_typematch_ident_scopegetset_634(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_attribute_635(bool is_can, std::shared_ptr<leaf::parsing::instance::field>& actual, leaf::parsing::instance::field_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_attribute(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_attribute_636(bool is_can, std::shared_ptr<leaf::parsing::instance::field>& actual, leaf::parsing::instance::field_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_attribute(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_attribute(depth + 1);
    actual->attributes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while637_638(bool is_can, std::shared_ptr<leaf::parsing::instance::field>& actual, leaf::parsing::instance::field_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_attribute_635(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_636(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_635(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_attribute_636(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: attribute (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_attribute_635(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_encapsulation_639(bool is_can, std::shared_ptr<leaf::parsing::instance::field>& actual, leaf::parsing::instance::field_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_encapsulation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_encapsulation(depth + 1);
    actual->encaps = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_unbound_640(bool is_can, std::shared_ptr<leaf::parsing::instance::field>& actual, leaf::parsing::instance::field_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__unbound(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__unbound(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_unbound_641(bool is_can, std::shared_ptr<leaf::parsing::instance::field>& actual, leaf::parsing::instance::field_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__unbound(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__unbound(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::if642_643(bool is_can, std::shared_ptr<leaf::parsing::instance::field>& actual, leaf::parsing::instance::field_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_unbound_640(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_unbound_641(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: unbound ({ Token: unbound (unbound)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_static = true;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_unbound_641(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: unbound ({ Token: unbound (unbound)}) }", depth);
                return false;
            }
            if (!is_can)
            {
                actual->is_static = true;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_typematch_ident_semicolon_644(bool is_can, std::shared_ptr<leaf::parsing::instance::field>& actual, leaf::parsing::instance::field_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__semicolon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_type_match(depth + 1);
    actual->target_type = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val7;
    skip();
    auto l9 = token__semicolon(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_field(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::field> fake;
    field_state state;
    if (!while637_638(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_encapsulation_639(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if642_643(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_typematch_ident_semicolon_644(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::field> leaf::parsing::instance::p_match_field(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::field>();
    std::shared_ptr<leaf::parsing::instance::field> fake;
    field_state state;
    resettable resettable2(*this);
    if (while637_638(true, fake, state, depth + 1))
    {
        resettable2.reset();
        while637_638(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_encapsulation_639(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_encapsulation_639(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if642_643(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if642_643(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_typematch_ident_semicolon_644(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_typematch_ident_semicolon_644(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_const_typematch_ident_equal_expor_semicolon_645(bool is_can, std::shared_ptr<leaf::parsing::instance::constant>& actual, leaf::parsing::instance::constant_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__const(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__equal(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_or(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__semicolon(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l11 = token__const(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto val12 = p_match_type_match(depth + 1);
    actual->target_type = val12;
    skip();
    auto val13 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val13;
    skip();
    auto l15 = token__equal(depth + 1).value();
    for (;l15 != 0; l15--)
    {
        next();
    }
    skip();
    auto val16 = lr_match_exp_or(depth + 1);
    actual->value = val16;
    skip();
    auto l18 = token__semicolon(depth + 1).value();
    for (;l18 != 0; l18--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_constant(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::constant> fake;
    constant_state state;
    if (!m_const_typematch_ident_equal_expor_semicolon_645(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::constant> leaf::parsing::instance::p_match_constant(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::constant>();
    std::shared_ptr<leaf::parsing::instance::constant> fake;
    constant_state state;
    resettable resettable2(*this);
    if (m_const_typematch_ident_equal_expor_semicolon_645(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_const_typematch_ident_equal_expor_semicolon_645(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_using_646(bool is_can, std::shared_ptr<leaf::parsing::instance::using_>& actual, leaf::parsing::instance::using__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__using(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__using(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_namespace_identnavigation_647(bool is_can, std::shared_ptr<leaf::parsing::instance::using_>& actual, leaf::parsing::instance::using__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__namespace(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_ident_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__namespace(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = lr_match_ident_navigation(depth + 1);
    actual->ident = val6;
    skip();
    if (!is_can)
    {
        actual->is_namespace = true;
    }
    return true;
}
bool leaf::parsing::instance::m_class_identnavigation_648(bool is_can, std::shared_ptr<leaf::parsing::instance::using_>& actual, leaf::parsing::instance::using__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__class(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_ident_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__class(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = lr_match_ident_navigation(depth + 1);
    actual->ident = val6;
    skip();
    if (!is_can)
    {
        actual->is_class = true;
    }
    return true;
}
bool leaf::parsing::instance::alternatives649(bool is_can, std::shared_ptr<leaf::parsing::instance::using_>& actual, leaf::parsing::instance::using__state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_namespace_identnavigation_647(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_namespace_identnavigation_647(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_class_identnavigation_648(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_class_identnavigation_648(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_equal_650(bool is_can, std::shared_ptr<leaf::parsing::instance::using_>& actual, leaf::parsing::instance::using__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__equal(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_equal_ident_651(bool is_can, std::shared_ptr<leaf::parsing::instance::using_>& actual, leaf::parsing::instance::using__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__equal(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->alias = val8;
    skip();
    return true;
}
bool leaf::parsing::instance::if652_653(bool is_can, std::shared_ptr<leaf::parsing::instance::using_>& actual, leaf::parsing::instance::using__state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_equal_650(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_equal_ident_651(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: = ({ Token: = (=)}), $ref: ident ({ Token: ident}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_equal_ident_651(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: = ({ Token: = (=)}), $ref: ident ({ Token: ident}) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::p_can_using_(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::using_> fake;
    using__state state;
    if (!m_using_646(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives649(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if652_653(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::using_> leaf::parsing::instance::p_match_using_(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::using_>();
    std::shared_ptr<leaf::parsing::instance::using_> fake;
    using__state state;
    resettable resettable2(*this);
    if (m_using_646(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_using_646(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives649(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives649(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (if652_653(true, fake, state, depth + 1))
    {
        resettable4.reset();
        if652_653(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_encapsulation_alias_654(bool is_can, std::shared_ptr<leaf::parsing::instance::alias_encapsulated>& actual, leaf::parsing::instance::alias_encapsulated_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_encapsulation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_alias(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_encapsulation(depth + 1);
    actual->encaps = val2;
    skip();
    auto val3 = p_match_alias(depth + 1);
    actual->actual = val3;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_alias_encapsulated(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::alias_encapsulated> fake;
    alias_encapsulated_state state;
    if (!m_encapsulation_alias_654(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::alias_encapsulated> leaf::parsing::instance::p_match_alias_encapsulated(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::alias_encapsulated>();
    std::shared_ptr<leaf::parsing::instance::alias_encapsulated> fake;
    alias_encapsulated_state state;
    resettable resettable2(*this);
    if (m_encapsulation_alias_654(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_encapsulation_alias_654(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_alias_ident_equal_typematch_655(bool is_can, std::shared_ptr<leaf::parsing::instance::alias>& actual, leaf::parsing::instance::alias_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__alias(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__equal(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__alias(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto val10 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->alias = val10;
    skip();
    auto l12 = token__equal(depth + 1).value();
    for (;l12 != 0; l12--)
    {
        next();
    }
    skip();
    auto val13 = p_match_type_match(depth + 1);
    actual->ident = val13;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_alias(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::alias> fake;
    alias_state state;
    if (!m_alias_ident_equal_typematch_655(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::alias> leaf::parsing::instance::p_match_alias(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::alias>();
    std::shared_ptr<leaf::parsing::instance::alias> fake;
    alias_state state;
    resettable resettable2(*this);
    if (m_alias_ident_equal_typematch_655(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_alias_ident_equal_typematch_655(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_callbody_656(bool is_can, std::shared_ptr<leaf::parsing::instance::call>& actual, leaf::parsing::instance::call_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_call_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->method = val4;
    skip();
    auto val5 = p_match_call_body(depth + 1);
    actual->body = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_call(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::call> fake;
    call_state state;
    if (!m_ident_callbody_656(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::call> leaf::parsing::instance::p_match_call(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::call>();
    std::shared_ptr<leaf::parsing::instance::call> fake;
    call_state state;
    resettable resettable2(*this);
    if (m_ident_callbody_656(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_ident_callbody_656(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_roundbracketopen_657(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_open(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_658(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_expression(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_659(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_expression(depth + 1);
    actual->args.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_roundbracketclose_660(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_expression_661(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_expression(depth + 1);
    actual->args.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_662(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives663(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_comma_expression_661(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_expression_661(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_comma_662(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_662(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { ,, expression, , }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while664_665(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_roundbracketclose_660(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives663(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_roundbracketclose_660(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives663(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives663(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_roundbracketclose_660(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::if666_667(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_expression_658(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_expression_659(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            while664_665(true, actual, state, depth + 1);
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_expression_659(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            while664_665(false, actual, state, depth + 1);
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_roundbracketclose_668(bool is_can, std::shared_ptr<leaf::parsing::instance::call_body>& actual, leaf::parsing::instance::call_body_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__round_bracket_close(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__round_bracket_close(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_call_body(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::call_body> fake;
    call_body_state state;
    if (!m_roundbracketopen_657(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if666_667(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_roundbracketclose_668(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::call_body> leaf::parsing::instance::p_match_call_body(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::call_body>();
    std::shared_ptr<leaf::parsing::instance::call_body> fake;
    call_body_state state;
    resettable resettable2(*this);
    if (m_roundbracketopen_657(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_roundbracketopen_657(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if666_667(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if666_667(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_roundbracketclose_668(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_roundbracketclose_668(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_free_expression_669(bool is_can, std::shared_ptr<leaf::parsing::instance::free>& actual, leaf::parsing::instance::free_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__free(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__free(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_expression(depth + 1);
    actual->value = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_free(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::free> fake;
    free_state state;
    if (!m_free_expression_669(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::free> leaf::parsing::instance::p_match_free(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::free>();
    std::shared_ptr<leaf::parsing::instance::free> fake;
    free_state state;
    resettable resettable2(*this);
    if (m_free_expression_669(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_free_expression_669(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_alloc_stack_typenavigation_squarebracketopen_expression_squarebracketclose_670(bool is_can, std::shared_ptr<leaf::parsing::instance::alloc>& actual, leaf::parsing::instance::alloc_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__alloc(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__stack(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__square_bracket_open(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__square_bracket_close(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l11 = token__alloc(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto l13 = token__stack(depth + 1).value();
    for (;l13 != 0; l13--)
    {
        next();
    }
    skip();
    auto val14 = lr_match_type_navigation(depth + 1);
    actual->type = val14;
    skip();
    auto l16 = token__square_bracket_open(depth + 1).value();
    for (;l16 != 0; l16--)
    {
        next();
    }
    skip();
    auto val17 = p_match_expression(depth + 1);
    actual->exp = val17;
    skip();
    auto l19 = token__square_bracket_close(depth + 1).value();
    for (;l19 != 0; l19--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_stack = true;
    }
    if (!is_can)
    {
        actual->is_heap = false;
    }
    return true;
}
bool leaf::parsing::instance::m_alloc_stack_typenavigation_callbody_671(bool is_can, std::shared_ptr<leaf::parsing::instance::alloc>& actual, leaf::parsing::instance::alloc_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__alloc(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__stack(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_call_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__alloc(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto l9 = token__stack(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto val10 = lr_match_type_navigation(depth + 1);
    actual->type = val10;
    skip();
    auto val11 = p_match_call_body(depth + 1);
    actual->body = val11;
    skip();
    if (!is_can)
    {
        actual->is_stack = true;
    }
    if (!is_can)
    {
        actual->is_heap = false;
    }
    return true;
}
bool leaf::parsing::instance::m_alloc_heap_typenavigation_squarebracketopen_expression_squarebracketclose_672(bool is_can, std::shared_ptr<leaf::parsing::instance::alloc>& actual, leaf::parsing::instance::alloc_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__alloc(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__heap(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__square_bracket_open(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l8 = token__square_bracket_close(depth + 1);
    if (l8.has_value())
    {
        for (auto i9 = l8.value(); i9 != 0; i9--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l11 = token__alloc(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto l13 = token__heap(depth + 1).value();
    for (;l13 != 0; l13--)
    {
        next();
    }
    skip();
    auto val14 = lr_match_type_navigation(depth + 1);
    actual->type = val14;
    skip();
    auto l16 = token__square_bracket_open(depth + 1).value();
    for (;l16 != 0; l16--)
    {
        next();
    }
    skip();
    auto val17 = p_match_expression(depth + 1);
    actual->exp = val17;
    skip();
    auto l19 = token__square_bracket_close(depth + 1).value();
    for (;l19 != 0; l19--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_stack = false;
    }
    if (!is_can)
    {
        actual->is_heap = true;
    }
    return true;
}
bool leaf::parsing::instance::m_alloc_heap_typenavigation_callbody_673(bool is_can, std::shared_ptr<leaf::parsing::instance::alloc>& actual, leaf::parsing::instance::alloc_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__alloc(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__heap(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_call_body(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__alloc(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto l9 = token__heap(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto val10 = lr_match_type_navigation(depth + 1);
    actual->type = val10;
    skip();
    auto val11 = p_match_call_body(depth + 1);
    actual->body = val11;
    skip();
    if (!is_can)
    {
        actual->is_stack = false;
    }
    if (!is_can)
    {
        actual->is_heap = true;
    }
    return true;
}
bool leaf::parsing::instance::alternatives674(bool is_can, std::shared_ptr<leaf::parsing::instance::alloc>& actual, leaf::parsing::instance::alloc_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_alloc_stack_typenavigation_squarebracketopen_expression_squarebracketclose_670(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_alloc_stack_typenavigation_squarebracketopen_expression_squarebracketclose_670(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_alloc_stack_typenavigation_callbody_671(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_alloc_stack_typenavigation_callbody_671(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_alloc_heap_typenavigation_squarebracketopen_expression_squarebracketclose_672(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_alloc_heap_typenavigation_squarebracketopen_expression_squarebracketclose_672(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_alloc_heap_typenavigation_callbody_673(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_alloc_heap_typenavigation_callbody_673(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_alloc(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::alloc> fake;
    alloc_state state;
    if (!alternatives674(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::alloc> leaf::parsing::instance::p_match_alloc(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::alloc>();
    std::shared_ptr<leaf::parsing::instance::alloc> fake;
    alloc_state state;
    resettable resettable2(*this);
    if (alternatives674(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives674(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typeof_roundbracketopen_typematch_roundbracketclose_675(bool is_can, std::shared_ptr<leaf::parsing::instance::typeof_>& actual, leaf::parsing::instance::typeof__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__typeof(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__round_bracket_close(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__typeof(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto l11 = token__round_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto val12 = p_match_type_match(depth + 1);
    actual->value = val12;
    skip();
    auto l14 = token__round_bracket_close(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_typeof_(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::typeof_> fake;
    typeof__state state;
    if (!m_typeof_roundbracketopen_typematch_roundbracketclose_675(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::typeof_> leaf::parsing::instance::p_match_typeof_(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::typeof_>();
    std::shared_ptr<leaf::parsing::instance::typeof_> fake;
    typeof__state state;
    resettable resettable2(*this);
    if (m_typeof_roundbracketopen_typematch_roundbracketclose_675(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_typeof_roundbracketopen_typematch_roundbracketclose_675(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_nameof_roundbracketopen_expor_roundbracketclose_676(bool is_can, std::shared_ptr<leaf::parsing::instance::nameof>& actual, leaf::parsing::instance::nameof_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__nameof(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_or(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__round_bracket_close(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__nameof(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto l11 = token__round_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto val12 = lr_match_exp_or(depth + 1);
    actual->value = val12;
    skip();
    auto l14 = token__round_bracket_close(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_nameof(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::nameof> fake;
    nameof_state state;
    if (!m_nameof_roundbracketopen_expor_roundbracketclose_676(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::nameof> leaf::parsing::instance::p_match_nameof(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::nameof>();
    std::shared_ptr<leaf::parsing::instance::nameof> fake;
    nameof_state state;
    resettable resettable2(*this);
    if (m_nameof_roundbracketopen_expor_roundbracketclose_676(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_nameof_roundbracketopen_expor_roundbracketclose_676(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_sizeof_roundbracketopen_typematch_roundbracketclose_677(bool is_can, std::shared_ptr<leaf::parsing::instance::sizeof_>& actual, leaf::parsing::instance::sizeof__state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__sizeof(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__round_bracket_open(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token__round_bracket_close(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l9 = token__sizeof(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    auto l11 = token__round_bracket_open(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    auto val12 = p_match_type_match(depth + 1);
    actual->type = val12;
    skip();
    auto l14 = token__round_bracket_close(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_sizeof_(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::sizeof_> fake;
    sizeof__state state;
    if (!m_sizeof_roundbracketopen_typematch_roundbracketclose_677(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::sizeof_> leaf::parsing::instance::p_match_sizeof_(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::sizeof_>();
    std::shared_ptr<leaf::parsing::instance::sizeof_> fake;
    sizeof__state state;
    resettable resettable2(*this);
    if (m_sizeof_roundbracketopen_typematch_roundbracketclose_677(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_sizeof_roundbracketopen_typematch_roundbracketclose_677(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_singlequotation_678(bool is_can, std::shared_ptr<leaf::parsing::instance::lifetime>& actual, leaf::parsing::instance::lifetime_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__single_quotation(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__single_quotation(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_scope_679(bool is_can, std::shared_ptr<leaf::parsing::instance::lifetime>& actual, leaf::parsing::instance::lifetime_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__scope(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__scope(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_scope = true;
    }
    return true;
}
bool leaf::parsing::instance::m_static_680(bool is_can, std::shared_ptr<leaf::parsing::instance::lifetime>& actual, leaf::parsing::instance::lifetime_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__static(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__static(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_static = true;
    }
    return true;
}
bool leaf::parsing::instance::m_ident_681(bool is_can, std::shared_ptr<leaf::parsing::instance::lifetime>& actual, leaf::parsing::instance::lifetime_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->named = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives682(bool is_can, std::shared_ptr<leaf::parsing::instance::lifetime>& actual, leaf::parsing::instance::lifetime_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_scope_679(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scope_679(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_static_680(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_static_680(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_681(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_681(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_lifetime(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::lifetime> fake;
    lifetime_state state;
    if (!m_singlequotation_678(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives682(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::lifetime> leaf::parsing::instance::p_match_lifetime(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::lifetime>();
    std::shared_ptr<leaf::parsing::instance::lifetime> fake;
    lifetime_state state;
    resettable resettable2(*this);
    if (m_singlequotation_678(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_singlequotation_678(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives682(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives682(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typenavigation_squarebracketopen_squarebracketclose_star_lifetime_683(bool is_can, std::shared_ptr<leaf::parsing::instance::type_match>& actual, leaf::parsing::instance::type_match_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__square_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__square_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_star(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_lifetime(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = lr_match_type_navigation(depth + 1);
    actual->base = val8;
    skip();
    auto l10 = token__square_bracket_open(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    auto l12 = token__square_bracket_close(depth + 1).value();
    for (;l12 != 0; l12--)
    {
        next();
    }
    skip();
    auto l14 = token_star(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    auto val15 = p_match_lifetime(depth + 1);
    actual->lifetime = val15;
    skip();
    if (!is_can)
    {
        actual->is_array = true;
    }
    if (!is_can)
    {
        actual->is_heap = true;
    }
    return true;
}
bool leaf::parsing::instance::m_typenavigation_star_lifetime_684(bool is_can, std::shared_ptr<leaf::parsing::instance::type_match>& actual, leaf::parsing::instance::type_match_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_star(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_lifetime(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = lr_match_type_navigation(depth + 1);
    actual->base = val4;
    skip();
    auto l6 = token_star(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    auto val7 = p_match_lifetime(depth + 1);
    actual->lifetime = val7;
    skip();
    if (!is_can)
    {
        actual->is_array = false;
    }
    if (!is_can)
    {
        actual->is_heap = true;
    }
    return true;
}
bool leaf::parsing::instance::m_typenavigation_lifetime_685(bool is_can, std::shared_ptr<leaf::parsing::instance::type_match>& actual, leaf::parsing::instance::type_match_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_lifetime(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_type_navigation(depth + 1);
    actual->base = val2;
    skip();
    auto val3 = p_match_lifetime(depth + 1);
    actual->lifetime = val3;
    skip();
    if (!is_can)
    {
        actual->is_array = false;
    }
    if (!is_can)
    {
        actual->is_heap = false;
    }
    return true;
}
bool leaf::parsing::instance::m_typenavigation_squarebracketopen_squarebracketclose_star_686(bool is_can, std::shared_ptr<leaf::parsing::instance::type_match>& actual, leaf::parsing::instance::type_match_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__square_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__square_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_star(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = lr_match_type_navigation(depth + 1);
    actual->base = val8;
    skip();
    auto l10 = token__square_bracket_open(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    auto l12 = token__square_bracket_close(depth + 1).value();
    for (;l12 != 0; l12--)
    {
        next();
    }
    skip();
    auto l14 = token_star(depth + 1).value();
    for (;l14 != 0; l14--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_array = true;
    }
    if (!is_can)
    {
        actual->is_heap = true;
    }
    return true;
}
bool leaf::parsing::instance::m_typenavigation_star_687(bool is_can, std::shared_ptr<leaf::parsing::instance::type_match>& actual, leaf::parsing::instance::type_match_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_star(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = lr_match_type_navigation(depth + 1);
    actual->base = val4;
    skip();
    auto l6 = token_star(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    if (!is_can)
    {
        actual->is_array = false;
    }
    if (!is_can)
    {
        actual->is_heap = true;
    }
    return true;
}
bool leaf::parsing::instance::m_typenavigation_688(bool is_can, std::shared_ptr<leaf::parsing::instance::type_match>& actual, leaf::parsing::instance::type_match_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_type_navigation(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_type_navigation(depth + 1);
    actual->base = val2;
    skip();
    if (!is_can)
    {
        actual->is_array = false;
    }
    if (!is_can)
    {
        actual->is_heap = false;
    }
    return true;
}
bool leaf::parsing::instance::alternatives689(bool is_can, std::shared_ptr<leaf::parsing::instance::type_match>& actual, leaf::parsing::instance::type_match_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_typenavigation_squarebracketopen_squarebracketclose_star_lifetime_683(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typenavigation_squarebracketopen_squarebracketclose_star_lifetime_683(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typenavigation_star_lifetime_684(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typenavigation_star_lifetime_684(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typenavigation_lifetime_685(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typenavigation_lifetime_685(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typenavigation_squarebracketopen_squarebracketclose_star_686(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typenavigation_squarebracketopen_squarebracketclose_star_686(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typenavigation_star_687(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typenavigation_star_687(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_typenavigation_688(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_typenavigation_688(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_type_match(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::type_match> fake;
    type_match_state state;
    if (!alternatives689(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::type_match> leaf::parsing::instance::p_match_type_match(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::type_match>();
    std::shared_ptr<leaf::parsing::instance::type_match> fake;
    type_match_state state;
    resettable resettable2(*this);
    if (alternatives689(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives689(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_stringformatablestart_690(bool is_can, std::shared_ptr<leaf::parsing::instance::string_formatable>& actual, leaf::parsing::instance::string_formatable_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string_formatable_start(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_string_formatable_start(depth + 1).value(), tok::STRING_FORMATABLE_START);
    actual->parts.push_back(val4);
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_691(bool is_can, std::shared_ptr<leaf::parsing::instance::string_formatable>& actual, leaf::parsing::instance::string_formatable_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_expression(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_stringformatableend_692(bool is_can, std::shared_ptr<leaf::parsing::instance::string_formatable>& actual, leaf::parsing::instance::string_formatable_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string_formatable_end(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token_string_formatable_end(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_stringformatablecontinuation_693(bool is_can, std::shared_ptr<leaf::parsing::instance::string_formatable>& actual, leaf::parsing::instance::string_formatable_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string_formatable_continuation(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_string_formatable_continuation(depth + 1).value(), tok::STRING_FORMATABLE_CONTINUATION);
    actual->parts.push_back(val4);
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_694(bool is_can, std::shared_ptr<leaf::parsing::instance::string_formatable>& actual, leaf::parsing::instance::string_formatable_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_expression(depth + 1);
    actual->parts.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while695_696(bool is_can, std::shared_ptr<leaf::parsing::instance::string_formatable>& actual, leaf::parsing::instance::string_formatable_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_stringformatableend_692(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            if (m_stringformatablecontinuation_693(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: string-formatable-continuation ({ Token: string-formatable-continuation}) }", depth);
                return false;
            }
            if (m_expression_694(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_stringformatableend_692(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (m_stringformatablecontinuation_693(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: string-formatable-continuation ({ Token: string-formatable-continuation}) }", depth);
                return false;
            }
            if (m_expression_694(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: expression (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_stringformatableend_692(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_stringformatableend_697(bool is_can, std::shared_ptr<leaf::parsing::instance::string_formatable>& actual, leaf::parsing::instance::string_formatable_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string_formatable_end(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_string_formatable_end(depth + 1).value(), tok::STRING_FORMATABLE_END);
    actual->parts.push_back(val4);
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_string_formatable(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::string_formatable> fake;
    string_formatable_state state;
    if (!m_stringformatablestart_690(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_expression_691(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while695_696(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_stringformatableend_697(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::string_formatable> leaf::parsing::instance::p_match_string_formatable(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::string_formatable>();
    std::shared_ptr<leaf::parsing::instance::string_formatable> fake;
    string_formatable_state state;
    resettable resettable2(*this);
    if (m_stringformatablestart_690(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_stringformatablestart_690(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_expression_691(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_expression_691(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (while695_696(true, fake, state, depth + 1))
    {
        resettable4.reset();
        while695_696(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_stringformatableend_697(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_stringformatableend_697(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_stringformatable_ident_698(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_string_formatable(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val6;
    skip();
    auto val7 = p_match_string_formatable(depth + 1);
    actual->value = val7;
    skip();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val8;
    skip();
    return true;
}
bool leaf::parsing::instance::m_stringformatable_ident_699(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_string_formatable(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_string_formatable(depth + 1);
    actual->value = val4;
    skip();
    auto val5 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_stringformatable_700(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_string_formatable(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val4;
    skip();
    auto val5 = p_match_string_formatable(depth + 1);
    actual->value = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_stringformatable_701(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_string_formatable(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_string_formatable(depth + 1);
    actual->value = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_stringformatablefake_ident_702(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_string_formatable_fake(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_ident(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val8;
    skip();
    auto val9 = create_token(token_string_formatable_fake(depth + 1).value(), tok::STRING_FORMATABLE_FAKE);
    actual->value = val9;
    skip();
    auto val10 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val10;
    skip();
    return true;
}
bool leaf::parsing::instance::m_stringformatablefake_ident_703(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string_formatable_fake(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_string_formatable_fake(depth + 1).value(), tok::STRING_FORMATABLE_FAKE);
    actual->value = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_stringformatablefake_704(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_string_formatable_fake(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val6;
    skip();
    auto val7 = create_token(token_string_formatable_fake(depth + 1).value(), tok::STRING_FORMATABLE_FAKE);
    actual->value = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_stringformatablefake_705(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string_formatable_fake(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_string_formatable_fake(depth + 1).value(), tok::STRING_FORMATABLE_FAKE);
    actual->value = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_string_ident_706(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_string(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_ident(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val8;
    skip();
    auto val9 = create_token(token_string(depth + 1).value(), tok::STRING);
    actual->value = val9;
    skip();
    auto val10 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val10;
    skip();
    return true;
}
bool leaf::parsing::instance::m_string_ident_707(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_string(depth + 1).value(), tok::STRING);
    actual->value = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_string_708(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_string(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val6;
    skip();
    auto val7 = create_token(token_string(depth + 1).value(), tok::STRING);
    actual->value = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_string_709(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_string(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_string(depth + 1).value(), tok::STRING);
    actual->value = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives710(bool is_can, std::shared_ptr<leaf::parsing::instance::string_literal>& actual, leaf::parsing::instance::string_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_ident_stringformatable_ident_698(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_stringformatable_ident_698(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_stringformatable_ident_699(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_stringformatable_ident_699(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_stringformatable_700(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_stringformatable_700(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_stringformatable_701(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_stringformatable_701(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_stringformatablefake_ident_702(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_stringformatablefake_ident_702(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_stringformatablefake_ident_703(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_stringformatablefake_ident_703(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_stringformatablefake_704(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_stringformatablefake_704(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_stringformatablefake_705(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_stringformatablefake_705(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_string_ident_706(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_string_ident_706(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_string_ident_707(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_string_ident_707(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_string_708(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_string_708(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_string_709(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_string_709(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_string_literal(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::string_literal> fake;
    string_literal_state state;
    if (!alternatives710(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::string_literal> leaf::parsing::instance::p_match_string_literal(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::string_literal>();
    std::shared_ptr<leaf::parsing::instance::string_literal> fake;
    string_literal_state state;
    resettable resettable2(*this);
    if (alternatives710(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives710(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_scalar_ident_711(bool is_can, std::shared_ptr<leaf::parsing::instance::scalar_literal>& actual, leaf::parsing::instance::scalar_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_scalar(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_ident(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val8;
    skip();
    auto val9 = create_token(token_scalar(depth + 1).value(), tok::SCALAR);
    actual->value = val9;
    skip();
    auto val10 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val10;
    skip();
    return true;
}
bool leaf::parsing::instance::m_scalar_ident_712(bool is_can, std::shared_ptr<leaf::parsing::instance::scalar_literal>& actual, leaf::parsing::instance::scalar_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_scalar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_scalar(depth + 1).value(), tok::SCALAR);
    actual->value = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_scalar_713(bool is_can, std::shared_ptr<leaf::parsing::instance::scalar_literal>& actual, leaf::parsing::instance::scalar_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_scalar(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val6;
    skip();
    auto val7 = create_token(token_scalar(depth + 1).value(), tok::SCALAR);
    actual->value = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_scalar_714(bool is_can, std::shared_ptr<leaf::parsing::instance::scalar_literal>& actual, leaf::parsing::instance::scalar_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_scalar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_scalar(depth + 1).value(), tok::SCALAR);
    actual->value = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives715(bool is_can, std::shared_ptr<leaf::parsing::instance::scalar_literal>& actual, leaf::parsing::instance::scalar_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_ident_scalar_ident_711(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_scalar_ident_711(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_scalar_ident_712(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scalar_ident_712(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_scalar_713(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_scalar_713(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_scalar_714(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_scalar_714(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_scalar_literal(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::scalar_literal> fake;
    scalar_literal_state state;
    if (!alternatives715(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::scalar_literal> leaf::parsing::instance::p_match_scalar_literal(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::scalar_literal>();
    std::shared_ptr<leaf::parsing::instance::scalar_literal> fake;
    scalar_literal_state state;
    resettable resettable2(*this);
    if (alternatives715(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives715(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_integerhex_ident_716(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_hex_literal>& actual, leaf::parsing::instance::integer_hex_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_integer_hex(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_ident(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val8;
    skip();
    auto val9 = create_token(token_integer_hex(depth + 1).value(), tok::INTEGER_HEX);
    actual->value = val9;
    skip();
    auto val10 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val10;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerhex_ident_717(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_hex_literal>& actual, leaf::parsing::instance::integer_hex_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_hex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_integer_hex(depth + 1).value(), tok::INTEGER_HEX);
    actual->value = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_integerhex_718(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_hex_literal>& actual, leaf::parsing::instance::integer_hex_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_integer_hex(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val6;
    skip();
    auto val7 = create_token(token_integer_hex(depth + 1).value(), tok::INTEGER_HEX);
    actual->value = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerhex_719(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_hex_literal>& actual, leaf::parsing::instance::integer_hex_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_hex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_hex(depth + 1).value(), tok::INTEGER_HEX);
    actual->value = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives720(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_hex_literal>& actual, leaf::parsing::instance::integer_hex_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_ident_integerhex_ident_716(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_integerhex_ident_716(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerhex_ident_717(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerhex_ident_717(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_integerhex_718(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_integerhex_718(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerhex_719(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerhex_719(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_integer_hex_literal(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::integer_hex_literal> fake;
    integer_hex_literal_state state;
    if (!alternatives720(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::integer_hex_literal> leaf::parsing::instance::p_match_integer_hex_literal(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::integer_hex_literal>();
    std::shared_ptr<leaf::parsing::instance::integer_hex_literal> fake;
    integer_hex_literal_state state;
    resettable resettable2(*this);
    if (alternatives720(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives720(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_integerbinary_ident_721(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_binary_literal>& actual, leaf::parsing::instance::integer_binary_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_integer_binary(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_ident(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val8;
    skip();
    auto val9 = create_token(token_integer_binary(depth + 1).value(), tok::INTEGER_BINARY);
    actual->value = val9;
    skip();
    auto val10 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val10;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerbinary_ident_722(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_binary_literal>& actual, leaf::parsing::instance::integer_binary_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_binary(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_integer_binary(depth + 1).value(), tok::INTEGER_BINARY);
    actual->value = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_integerbinary_723(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_binary_literal>& actual, leaf::parsing::instance::integer_binary_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_integer_binary(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val6;
    skip();
    auto val7 = create_token(token_integer_binary(depth + 1).value(), tok::INTEGER_BINARY);
    actual->value = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerbinary_724(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_binary_literal>& actual, leaf::parsing::instance::integer_binary_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_binary(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_binary(depth + 1).value(), tok::INTEGER_BINARY);
    actual->value = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives725(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_binary_literal>& actual, leaf::parsing::instance::integer_binary_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_ident_integerbinary_ident_721(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_integerbinary_ident_721(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerbinary_ident_722(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerbinary_ident_722(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_integerbinary_723(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_integerbinary_723(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerbinary_724(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerbinary_724(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_integer_binary_literal(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::integer_binary_literal> fake;
    integer_binary_literal_state state;
    if (!alternatives725(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::integer_binary_literal> leaf::parsing::instance::p_match_integer_binary_literal(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::integer_binary_literal>();
    std::shared_ptr<leaf::parsing::instance::integer_binary_literal> fake;
    integer_binary_literal_state state;
    resettable resettable2(*this);
    if (alternatives725(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives725(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_integer_ident_726(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_literal>& actual, leaf::parsing::instance::integer_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_integer(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_ident(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val8;
    skip();
    auto val9 = create_token(token_integer(depth + 1).value(), tok::INTEGER);
    actual->value = val9;
    skip();
    auto val10 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val10;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integer_ident_727(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_literal>& actual, leaf::parsing::instance::integer_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_integer(depth + 1).value(), tok::INTEGER);
    actual->value = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_integer_728(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_literal>& actual, leaf::parsing::instance::integer_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_integer(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val6;
    skip();
    auto val7 = create_token(token_integer(depth + 1).value(), tok::INTEGER);
    actual->value = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integer_729(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_literal>& actual, leaf::parsing::instance::integer_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer(depth + 1).value(), tok::INTEGER);
    actual->value = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives730(bool is_can, std::shared_ptr<leaf::parsing::instance::integer_literal>& actual, leaf::parsing::instance::integer_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_ident_integer_ident_726(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_integer_ident_726(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integer_ident_727(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integer_ident_727(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_integer_728(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_integer_728(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integer_729(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integer_729(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_integer_literal(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::integer_literal> fake;
    integer_literal_state state;
    if (!alternatives730(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::integer_literal> leaf::parsing::instance::p_match_integer_literal(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::integer_literal>();
    std::shared_ptr<leaf::parsing::instance::integer_literal> fake;
    integer_literal_state state;
    resettable resettable2(*this);
    if (alternatives730(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives730(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_char_ident_731(bool is_can, std::shared_ptr<leaf::parsing::instance::char_literal>& actual, leaf::parsing::instance::char_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_char_(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l6 = token_ident(depth + 1);
    if (l6.has_value())
    {
        for (auto i7 = l6.value(); i7 != 0; i7--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val8;
    skip();
    auto val9 = create_token(token_char_(depth + 1).value(), tok::CHAR_);
    actual->value = val9;
    skip();
    auto val10 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val10;
    skip();
    return true;
}
bool leaf::parsing::instance::m_char_ident_732(bool is_can, std::shared_ptr<leaf::parsing::instance::char_literal>& actual, leaf::parsing::instance::char_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_char_(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_char_(depth + 1).value(), tok::CHAR_);
    actual->value = val6;
    skip();
    auto val7 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->postfix = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_char_733(bool is_can, std::shared_ptr<leaf::parsing::instance::char_literal>& actual, leaf::parsing::instance::char_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_char_(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->prefix = val6;
    skip();
    auto val7 = create_token(token_char_(depth + 1).value(), tok::CHAR_);
    actual->value = val7;
    skip();
    return true;
}
bool leaf::parsing::instance::m_char_734(bool is_can, std::shared_ptr<leaf::parsing::instance::char_literal>& actual, leaf::parsing::instance::char_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_char_(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_char_(depth + 1).value(), tok::CHAR_);
    actual->value = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives735(bool is_can, std::shared_ptr<leaf::parsing::instance::char_literal>& actual, leaf::parsing::instance::char_literal_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_ident_char_ident_731(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_char_ident_731(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_char_ident_732(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_char_ident_732(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_ident_char_733(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_ident_char_733(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_char_734(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_char_734(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_char_literal(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::char_literal> fake;
    char_literal_state state;
    if (!alternatives735(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::char_literal> leaf::parsing::instance::p_match_char_literal(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::char_literal>();
    std::shared_ptr<leaf::parsing::instance::char_literal> fake;
    char_literal_state state;
    resettable resettable2(*this);
    if (alternatives735(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives735(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_typematch_ident_736(bool is_can, std::shared_ptr<leaf::parsing::instance::declaration>& actual, leaf::parsing::instance::declaration_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_type_match(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_type_match(depth + 1);
    actual->type = val4;
    skip();
    auto val5 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->name = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_declaration(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::declaration> fake;
    declaration_state state;
    if (!m_typematch_ident_736(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::declaration> leaf::parsing::instance::p_match_declaration(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::declaration>();
    std::shared_ptr<leaf::parsing::instance::declaration> fake;
    declaration_state state;
    resettable resettable2(*this);
    if (m_typematch_ident_736(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_typematch_ident_736(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_return_semicolon_737(bool is_can, std::shared_ptr<leaf::parsing::instance::return_statement>& actual, leaf::parsing::instance::return_statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__return(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__semicolon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__return(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto l9 = token__semicolon(depth + 1).value();
    for (;l9 != 0; l9--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_return_expression_semicolon_738(bool is_can, std::shared_ptr<leaf::parsing::instance::return_statement>& actual, leaf::parsing::instance::return_statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__return(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__semicolon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__return(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_expression(depth + 1);
    actual->exp = val8;
    skip();
    auto l10 = token__semicolon(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives739(bool is_can, std::shared_ptr<leaf::parsing::instance::return_statement>& actual, leaf::parsing::instance::return_statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_return_semicolon_737(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_return_semicolon_737(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_return_expression_semicolon_738(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_return_expression_semicolon_738(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_return_statement(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::return_statement> fake;
    return_statement_state state;
    if (!alternatives739(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::return_statement> leaf::parsing::instance::p_match_return_statement(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::return_statement>();
    std::shared_ptr<leaf::parsing::instance::return_statement> fake;
    return_statement_state state;
    resettable resettable2(*this);
    if (alternatives739(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives739(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_alias_740(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_alias(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_alias(depth + 1);
    actual->aliases = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_constant_741(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_constant(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_constant(depth + 1);
    actual->constants = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_returnstatement_742(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_return_statement(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_return_statement(depth + 1);
    actual->ret = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_declaration_equal_expression_semicolon_743(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_declaration(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__semicolon(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val6 = p_match_declaration(depth + 1);
    actual->fwrd_decl = val6;
    skip();
    auto l8 = token__equal(depth + 1).value();
    for (;l8 != 0; l8--)
    {
        next();
    }
    skip();
    auto val9 = p_match_expression(depth + 1);
    actual->exp = val9;
    skip();
    auto l11 = token__semicolon(depth + 1).value();
    for (;l11 != 0; l11--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_declaration_semicolon_744(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_declaration(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__semicolon(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_declaration(depth + 1);
    actual->fwrd_decl = val4;
    skip();
    auto l6 = token__semicolon(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_expression_semicolon_745(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l2 = token__semicolon(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = p_match_expression(depth + 1);
    actual->exp = val4;
    skip();
    auto l6 = token__semicolon(depth + 1).value();
    for (;l6 != 0; l6--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_semicolon_746(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__semicolon(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__semicolon(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_pragma_747(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma(depth + 1);
    actual->pragma = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives748(bool is_can, std::shared_ptr<leaf::parsing::instance::statement>& actual, leaf::parsing::instance::statement_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_alias_740(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_alias_740(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_constant_741(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_constant_741(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_returnstatement_742(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_returnstatement_742(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_declaration_equal_expression_semicolon_743(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_declaration_equal_expression_semicolon_743(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_declaration_semicolon_744(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_declaration_semicolon_744(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_expression_semicolon_745(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_expression_semicolon_745(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_semicolon_746(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_semicolon_746(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_pragma_747(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragma_747(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_statement(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::statement> fake;
    statement_state state;
    if (!alternatives748(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::statement> leaf::parsing::instance::p_match_statement(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::statement>();
    std::shared_ptr<leaf::parsing::instance::statement> fake;
    statement_state state;
    resettable resettable2(*this);
    if (alternatives748(true, fake, state, depth + 1))
    {
        resettable2.reset();
        alternatives748(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_auto815_749(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__auto_815(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__auto_815(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_exclamationgreaterthen_750(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__exclamation_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__exclamation_greater_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_pragmadisable_751(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma_disable(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma_disable(depth + 1);
    actual->contents.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_pragmaenable_752(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma_enable(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma_enable(depth + 1);
    actual->contents.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_pragmasize_753(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma_size(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma_size(depth + 1);
    actual->contents.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_pragmaalign_754(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma_align(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma_align(depth + 1);
    actual->contents.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives755(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_pragmadisable_751(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragmadisable_751(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_pragmaenable_752(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragmaenable_752(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_pragmasize_753(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragmasize_753(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_pragmaalign_754(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragmaalign_754(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { pragma-disable, pragma-enable, pragma-size, pragma-align }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while756_757(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_exclamationgreaterthen_750(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives755(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_exclamationgreaterthen_750(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives755(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives755(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_exclamationgreaterthen_750(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_exclamationgreaterthen_758(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma>& actual, leaf::parsing::instance::pragma_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__exclamation_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__exclamation_greater_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_pragma(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::pragma> fake;
    pragma_state state;
    if (!m_auto815_749(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while756_757(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_exclamationgreaterthen_758(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::pragma> leaf::parsing::instance::p_match_pragma(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::pragma>();
    std::shared_ptr<leaf::parsing::instance::pragma> fake;
    pragma_state state;
    resettable resettable2(*this);
    if (m_auto815_749(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_auto815_749(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (while756_757(true, fake, state, depth + 1))
    {
        resettable3.reset();
        while756_757(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (m_exclamationgreaterthen_758(true, fake, state, depth + 1))
    {
        resettable4.reset();
        m_exclamationgreaterthen_758(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_align_759(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_align>& actual, leaf::parsing::instance::pragma_align_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__align(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__align(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerbinary_760(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_align>& actual, leaf::parsing::instance::pragma_align_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_binary(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_binary(depth + 1).value(), tok::INTEGER_BINARY);
    actual->bytes = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerhex_761(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_align>& actual, leaf::parsing::instance::pragma_align_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_hex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_hex(depth + 1).value(), tok::INTEGER_HEX);
    actual->bytes = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integer_762(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_align>& actual, leaf::parsing::instance::pragma_align_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer(depth + 1).value(), tok::INTEGER);
    actual->bytes = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives763(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_align>& actual, leaf::parsing::instance::pragma_align_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_integerbinary_760(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerbinary_760(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerhex_761(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerhex_761(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integer_762(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integer_762(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_pragma_align(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::pragma_align> fake;
    pragma_align_state state;
    if (!m_align_759(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives763(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::pragma_align> leaf::parsing::instance::p_match_pragma_align(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::pragma_align>();
    std::shared_ptr<leaf::parsing::instance::pragma_align> fake;
    pragma_align_state state;
    resettable resettable2(*this);
    if (m_align_759(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_align_759(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives763(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives763(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_size_764(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_size>& actual, leaf::parsing::instance::pragma_size_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__size(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__size(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerbinary_765(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_size>& actual, leaf::parsing::instance::pragma_size_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_binary(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_binary(depth + 1).value(), tok::INTEGER_BINARY);
    actual->bytes = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integerhex_766(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_size>& actual, leaf::parsing::instance::pragma_size_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer_hex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer_hex(depth + 1).value(), tok::INTEGER_HEX);
    actual->bytes = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_integer_767(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_size>& actual, leaf::parsing::instance::pragma_size_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_integer(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_integer(depth + 1).value(), tok::INTEGER);
    actual->bytes = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives768(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_size>& actual, leaf::parsing::instance::pragma_size_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_integerbinary_765(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerbinary_765(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integerhex_766(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integerhex_766(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_integer_767(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_integer_767(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::p_can_pragma_size(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::pragma_size> fake;
    pragma_size_state state;
    if (!m_size_764(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives768(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::pragma_size> leaf::parsing::instance::p_match_pragma_size(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::pragma_size>();
    std::shared_ptr<leaf::parsing::instance::pragma_size> fake;
    pragma_size_state state;
    resettable resettable2(*this);
    if (m_size_764(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_size_764(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives768(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives768(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_disable_769(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_disable>& actual, leaf::parsing::instance::pragma_disable_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__disable(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__disable(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_770(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_disable>& actual, leaf::parsing::instance::pragma_disable_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->code = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_pragma_disable(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::pragma_disable> fake;
    pragma_disable_state state;
    if (!m_disable_769(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_ident_770(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::pragma_disable> leaf::parsing::instance::p_match_pragma_disable(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::pragma_disable>();
    std::shared_ptr<leaf::parsing::instance::pragma_disable> fake;
    pragma_disable_state state;
    resettable resettable2(*this);
    if (m_disable_769(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_disable_769(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_ident_770(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_ident_770(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_enable_771(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_enable>& actual, leaf::parsing::instance::pragma_enable_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__enable(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__enable(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_772(bool is_can, std::shared_ptr<leaf::parsing::instance::pragma_enable>& actual, leaf::parsing::instance::pragma_enable_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->code = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_pragma_enable(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::pragma_enable> fake;
    pragma_enable_state state;
    if (!m_enable_771(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_ident_772(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::pragma_enable> leaf::parsing::instance::p_match_pragma_enable(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::pragma_enable>();
    std::shared_ptr<leaf::parsing::instance::pragma_enable> fake;
    pragma_enable_state state;
    resettable resettable2(*this);
    if (m_enable_771(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_enable_771(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_ident_772(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_ident_772(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_773(bool is_can, std::shared_ptr<leaf::parsing::instance::template_usage_item>& actual, leaf::parsing::instance::template_usage_item_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->key = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_template_usage_item(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::template_usage_item> fake;
    template_usage_item_state state;
    if (!m_ident_773(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::template_usage_item> leaf::parsing::instance::p_match_template_usage_item(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::template_usage_item>();
    std::shared_ptr<leaf::parsing::instance::template_usage_item> fake;
    template_usage_item_state state;
    resettable resettable2(*this);
    if (m_ident_773(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_ident_773(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_lessthen_774(bool is_can, std::shared_ptr<leaf::parsing::instance::template_usage>& actual, leaf::parsing::instance::template_usage_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__less_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_templateusageitem_775(bool is_can, std::shared_ptr<leaf::parsing::instance::template_usage>& actual, leaf::parsing::instance::template_usage_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_usage_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_usage_item(depth + 1);
    actual->items.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_776(bool is_can, std::shared_ptr<leaf::parsing::instance::template_usage>& actual, leaf::parsing::instance::template_usage_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_templateusageitem_777(bool is_can, std::shared_ptr<leaf::parsing::instance::template_usage>& actual, leaf::parsing::instance::template_usage_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_template_usage_item(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_template_usage_item(depth + 1);
    actual->items.push_back(val6);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives778(bool is_can, std::shared_ptr<leaf::parsing::instance::template_usage>& actual, leaf::parsing::instance::template_usage_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_comma_templateusageitem_777(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_templateusageitem_777(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { ,, template-usage-item }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while779_780(bool is_can, std::shared_ptr<leaf::parsing::instance::template_usage>& actual, leaf::parsing::instance::template_usage_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_comma_776(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            while (!alternatives778(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_comma_776(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (!alternatives778(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives778(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_comma_776(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_greaterthen_781(bool is_can, std::shared_ptr<leaf::parsing::instance::template_usage>& actual, leaf::parsing::instance::template_usage_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__greater_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_template_usage(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::template_usage> fake;
    template_usage_state state;
    if (!m_lessthen_774(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_templateusageitem_775(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while779_780(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_greaterthen_781(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::template_usage> leaf::parsing::instance::p_match_template_usage(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::template_usage>();
    std::shared_ptr<leaf::parsing::instance::template_usage> fake;
    template_usage_state state;
    resettable resettable2(*this);
    if (m_lessthen_774(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_lessthen_774(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (m_templateusageitem_775(true, fake, state, depth + 1))
    {
        resettable3.reset();
        m_templateusageitem_775(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (while779_780(true, fake, state, depth + 1))
    {
        resettable4.reset();
        while779_780(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_greaterthen_781(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_greaterthen_781(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_ident_782(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition_item_direct_type>& actual, leaf::parsing::instance::template_definition_item_direct_type_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->key = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::m_equal_783(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition_item_direct_type>& actual, leaf::parsing::instance::template_definition_item_direct_type_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__equal(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_equal_expvalue_784(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition_item_direct_type>& actual, leaf::parsing::instance::template_definition_item_direct_type_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_value(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__equal(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_exp_value(depth + 1);
    actual->value = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::if785_786(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition_item_direct_type>& actual, leaf::parsing::instance::template_definition_item_direct_type_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_equal_783(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            if (m_equal_expvalue_784(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: = ({ Token: = (=)}), $ref: exp-value (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            if (m_equal_expvalue_784(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: = ({ Token: = (=)}), $ref: exp-value (XCG.Parsing.Production) }", depth);
                return false;
            }
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::p_can_template_definition_item_direct_type(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::template_definition_item_direct_type> fake;
    template_definition_item_direct_type_state state;
    if (!m_ident_782(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!if785_786(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::template_definition_item_direct_type> leaf::parsing::instance::p_match_template_definition_item_direct_type(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::template_definition_item_direct_type>();
    std::shared_ptr<leaf::parsing::instance::template_definition_item_direct_type> fake;
    template_definition_item_direct_type_state state;
    resettable resettable2(*this);
    if (m_ident_782(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_ident_782(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (if785_786(true, fake, state, depth + 1))
    {
        resettable3.reset();
        if785_786(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_identifier_ident_787(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition_item_identifier>& actual, leaf::parsing::instance::template_definition_item_identifier_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__identifier(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__identifier(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->key = val8;
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_template_definition_item_identifier(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::template_definition_item_identifier> fake;
    template_definition_item_identifier_state state;
    if (!m_identifier_ident_787(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::template_definition_item_identifier> leaf::parsing::instance::p_match_template_definition_item_identifier(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::template_definition_item_identifier>();
    std::shared_ptr<leaf::parsing::instance::template_definition_item_identifier> fake;
    template_definition_item_identifier_state state;
    resettable resettable2(*this);
    if (m_identifier_ident_787(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_identifier_ident_787(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_lessthen_788(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__less_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinitionitemidentifier_789(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition_item_identifier(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition_item_identifier(depth + 1);
    actual->items.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinitionitemdirecttype_790(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition_item_direct_type(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition_item_direct_type(depth + 1);
    actual->items.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives791(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_templatedefinitionitemidentifier_789(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_templatedefinitionitemidentifier_789(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_templatedefinitionitemdirecttype_790(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_templatedefinitionitemdirecttype_790(false, actual, state, depth + 1);
            return true;
        }
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::m_comma_792(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinitionitemidentifier_793(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition_item_identifier(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition_item_identifier(depth + 1);
    actual->items.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_templatedefinitionitemdirecttype_794(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_definition_item_direct_type(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_definition_item_direct_type(depth + 1);
    actual->items.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_comma_795(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__comma(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__comma(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives796(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_templatedefinitionitemidentifier_793(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_templatedefinitionitemidentifier_793(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_templatedefinitionitemdirecttype_794(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_templatedefinitionitemdirecttype_794(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_comma_795(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_comma_795(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { template-definition-item-identifier, template-definition-item-direct-type, , }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while797_798(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_comma_792(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            while (!alternatives796(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = m_comma_792(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (!alternatives796(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives796(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = m_comma_792(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::m_greaterthen_799(bool is_can, std::shared_ptr<leaf::parsing::instance::template_definition>& actual, leaf::parsing::instance::template_definition_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__greater_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::p_can_template_definition(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::template_definition> fake;
    template_definition_state state;
    if (!m_lessthen_788(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!alternatives791(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while797_798(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!m_greaterthen_799(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::template_definition> leaf::parsing::instance::p_match_template_definition(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::template_definition>();
    std::shared_ptr<leaf::parsing::instance::template_definition> fake;
    template_definition_state state;
    resettable resettable2(*this);
    if (m_lessthen_788(true, fake, state, depth + 1))
    {
        resettable2.reset();
        m_lessthen_788(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (alternatives791(true, fake, state, depth + 1))
    {
        resettable3.reset();
        alternatives791(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable4(*this);
    if (while797_798(true, fake, state, depth + 1))
    {
        resettable4.reset();
        while797_798(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable5(*this);
    if (m_greaterthen_799(true, fake, state, depth + 1))
    {
        resettable5.reset();
        m_greaterthen_799(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_using_800(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_using_(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_using_801(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    p_match_using_(depth + 1);
    skip();
    return true;
}
bool leaf::parsing::instance::m_using_802(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_using_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_using_(depth + 1);
    actual->usings.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::while803_804(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = m_using_801(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        while (cond3 && current() != '\0')
        {
            if (m_using_802(true, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: using (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_using_801(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (cond3 && current() != '\0')
        {
            if (m_using_802(false, actual, state, depth + 1))
            {
                skip();
            }
            else if (is_can)
            {
                return false;
            }
            else
            {
                report("Failed to match { $ref: using (XCG.Parsing.Production) }", depth);
                return false;
            }
            resettable resettable2(*this);
            cond3 = m_using_801(true, actual, state, depth + 1);
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::if805_806(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond2 = m_using_800(true, actual, state, depth + 1);
    resettable1.reset();
    if (is_can)
    {
        if (cond2)
        {
            while803_804(true, actual, state, depth + 1);
            return true;
        }
        return true;
    }
    else
    {
        if (cond2)
        {
            while803_804(false, actual, state, depth + 1);
            return true;
        }
        return true;
    }
}
bool leaf::parsing::instance::m_contract_807(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_contract(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_contract(depth + 1);
    actual->contract.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_alias_808(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_alias(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_alias(depth + 1);
    actual->aliases.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_namespace_809(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_namespace_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_namespace_(depth + 1);
    actual->namespaces.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_conversion_810(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_conversion(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_conversion(depth + 1);
    actual->conversions.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_class_811(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_class_(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_class_(depth + 1);
    actual->classes.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_method_812(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_method(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_method(depth + 1);
    actual->methods.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_property_813(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_property(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_property(depth + 1);
    actual->properties.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_field_814(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_field(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_field(depth + 1);
    actual->fields.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::m_pragma_815(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_pragma(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_pragma(depth + 1);
    actual->pragmas.push_back(val2);
    skip();
    return true;
}
bool leaf::parsing::instance::alternatives816(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (m_contract_807(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_contract_807(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_alias_808(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_alias_808(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_namespace_809(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_namespace_809(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_conversion_810(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_conversion_810(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_class_811(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_class_811(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_method_812(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_method_812(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_property_813(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_property_813(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_field_814(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_field_814(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (m_pragma_815(true, actual, state, depth + 1))
    {
        if (is_can)
        {
            return true;
        }
        else
        {
            resettable1.reset();
            m_pragma_815(false, actual, state, depth + 1);
            return true;
        }
    }
    else if (!is_can)
    {
        report("Failed to match one of the following: { contract, alias, namespace, conversion, class, method, property, field, pragma }", depth);
    }
    resettable1.reset();
    return false;
}
bool leaf::parsing::instance::while817_818(bool is_can, std::shared_ptr<leaf::parsing::instance::main>& actual, leaf::parsing::instance::main_state& state, size_t depth)
{
    resettable resettable1(*this);
    bool cond3 = current() == '\0';
    resettable1.reset();
    if (is_can)
    {
        while (!cond3 && current() != '\0')
        {
            while (!alternatives816(true, actual, state, depth + 1) && current() != '\0')
            {
                next();
            }
            resettable resettable2(*this);
            cond3 = current() == '\0';
            resettable2.reset();
        }
        return true;
    }
    else
    {
        while (!cond3 && current() != '\0')
        {
            if (!alternatives816(false, actual, state, depth + 1))
            {
                while (current() != '\0')
                {
                    resettable resettable4(*this);
                    if (alternatives816(true, actual, state, depth + 1))
                    {
                        resettable4.reset();
                        break;
                    }
                    next();
                }
            }
            resettable resettable2(*this);
            cond3 = current() == '\0';
            resettable2.reset();
        }
        return true;
    }
}
bool leaf::parsing::instance::p_can_main(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::main> fake;
    main_state state;
    if (!if805_806(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    else if (!while817_818(true, fake, state, depth + 1))
    {
        resettable1.reset();
        return false;
    }
    return true;
}
std::shared_ptr<leaf::parsing::instance::main> leaf::parsing::instance::p_match_main(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::main>();
    std::shared_ptr<leaf::parsing::instance::main> fake;
    main_state state;
    resettable resettable2(*this);
    if (if805_806(true, fake, state, depth + 1))
    {
        resettable2.reset();
        if805_806(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    resettable resettable3(*this);
    if (while817_818(true, fake, state, depth + 1))
    {
        resettable3.reset();
        while817_818(false, actual, state, depth + 1);
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
    }
    return actual;
}
bool leaf::parsing::instance::m_expchain_dot_call_819(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain>& actual, leaf::parsing::instance::exp_chain_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__dot(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_call(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__dot(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_call(depth + 1);
    actual->chain_call = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expchain_dot_ident_820(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain>& actual, leaf::parsing::instance::exp_chain_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__dot(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__dot(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->chain_access = val8;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expchain_minusgreaterthen_call_821(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain>& actual, leaf::parsing::instance::exp_chain_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__minus_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_call(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l5 = token__minus_greater_then(depth + 1).value();
    for (;l5 != 0; l5--)
    {
        next();
    }
    skip();
    auto val6 = p_match_call(depth + 1);
    actual->indirection_call = val6;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expchain_minusgreaterthen_ident_822(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain>& actual, leaf::parsing::instance::exp_chain_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__minus_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__minus_greater_then(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->indirection_access = val8;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expchain_squarebracketopen_expression_squarebracketclose_823(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain>& actual, leaf::parsing::instance::exp_chain_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__square_bracket_open(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_expression(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token__square_bracket_close(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__square_bracket_open(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = p_match_expression(depth + 1);
    actual->chain_indexer = val8;
    skip();
    auto l10 = token__square_bracket_close(depth + 1).value();
    for (;l10 != 0; l10--)
    {
        next();
    }
    skip();
    return true;
}
bool leaf::parsing::instance::m_expchain_templateusage_824(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain>& actual, leaf::parsing::instance::exp_chain_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_usage(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_usage(depth + 1);
    actual->chain_template = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expchainstart_825(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_chain>& actual, leaf::parsing::instance::exp_chain_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_exp_chain_start(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_exp_chain_start(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_chain(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_chain> fake;
    exp_chain_state state;
    if (!m_expchainstart_825(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expchain_dot_call_819(true, fake, state, depth + 1))
        {
        }
        else if (m_expchain_dot_ident_820(true, fake, state, depth + 1))
        {
        }
        else if (m_expchain_minusgreaterthen_call_821(true, fake, state, depth + 1))
        {
        }
        else if (m_expchain_minusgreaterthen_ident_822(true, fake, state, depth + 1))
        {
        }
        else if (m_expchain_squarebracketopen_expression_squarebracketclose_823(true, fake, state, depth + 1))
        {
        }
        else if (m_expchain_templateusage_824(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_chain> leaf::parsing::instance::lr_match_exp_chain(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_chain>();
    std::shared_ptr<leaf::parsing::instance::exp_chain> fake;
    exp_chain_state state;
    if (!m_expchainstart_825(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expchain_dot_call_819(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_chain>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expchain_dot_call_819(false, actual, state, depth + 1);
        }
        else if (m_expchain_dot_ident_820(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_chain>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expchain_dot_ident_820(false, actual, state, depth + 1);
        }
        else if (m_expchain_minusgreaterthen_call_821(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_chain>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expchain_minusgreaterthen_call_821(false, actual, state, depth + 1);
        }
        else if (m_expchain_minusgreaterthen_ident_822(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_chain>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expchain_minusgreaterthen_ident_822(false, actual, state, depth + 1);
        }
        else if (m_expchain_squarebracketopen_expression_squarebracketclose_823(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_chain>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expchain_squarebracketopen_expression_squarebracketclose_823(false, actual, state, depth + 1);
        }
        else if (m_expchain_templateusage_824(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_chain>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expchain_templateusage_824(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_expbinary4_lessthenlessthen_expunary_826(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_4>& actual, leaf::parsing::instance::exp_binary_4_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_less_then(depth + 1).value(), tok::_LESS_THEN_LESS_THEN);
    actual->operator_ = val4;
    skip();
    auto val5 = p_match_exp_unary(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expbinary4_greaterthengreaterthen_expunary_827(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_4>& actual, leaf::parsing::instance::exp_binary_4_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_greater_then(depth + 1).value(), tok::_GREATER_THEN_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    auto val5 = p_match_exp_unary(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expbinary4_lessthenlessthenlessthen_expunary_828(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_4>& actual, leaf::parsing::instance::exp_binary_4_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_less_then_less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_less_then_less_then(depth + 1).value(), tok::_LESS_THEN_LESS_THEN_LESS_THEN);
    actual->operator_ = val4;
    skip();
    auto val5 = p_match_exp_unary(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expbinary4_greaterthengreaterthengreaterthen_expunary_829(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_4>& actual, leaf::parsing::instance::exp_binary_4_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_greater_then_greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_greater_then_greater_then(depth + 1).value(), tok::_GREATER_THEN_GREATER_THEN_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    auto val5 = p_match_exp_unary(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expunary_830(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_4>& actual, leaf::parsing::instance::exp_binary_4_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_exp_unary(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_exp_unary(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_binary_4(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_binary_4> fake;
    exp_binary_4_state state;
    if (!m_expunary_830(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expbinary4_lessthenlessthen_expunary_826(true, fake, state, depth + 1))
        {
        }
        else if (m_expbinary4_greaterthengreaterthen_expunary_827(true, fake, state, depth + 1))
        {
        }
        else if (m_expbinary4_lessthenlessthenlessthen_expunary_828(true, fake, state, depth + 1))
        {
        }
        else if (m_expbinary4_greaterthengreaterthengreaterthen_expunary_829(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_binary_4> leaf::parsing::instance::lr_match_exp_binary_4(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_binary_4>();
    std::shared_ptr<leaf::parsing::instance::exp_binary_4> fake;
    exp_binary_4_state state;
    if (!m_expunary_830(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expbinary4_lessthenlessthen_expunary_826(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_binary_4>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expbinary4_lessthenlessthen_expunary_826(false, actual, state, depth + 1);
        }
        else if (m_expbinary4_greaterthengreaterthen_expunary_827(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_binary_4>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expbinary4_greaterthengreaterthen_expunary_827(false, actual, state, depth + 1);
        }
        else if (m_expbinary4_lessthenlessthenlessthen_expunary_828(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_binary_4>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expbinary4_lessthenlessthenlessthen_expunary_828(false, actual, state, depth + 1);
        }
        else if (m_expbinary4_greaterthengreaterthengreaterthen_expunary_829(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_binary_4>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expbinary4_greaterthengreaterthengreaterthen_expunary_829(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_expbinary3_ampersand_expbinary4_831(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_3>& actual, leaf::parsing::instance::exp_binary_3_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__ampersand(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_binary_4(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__ampersand(depth + 1).value(), tok::_AMPERSAND);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_binary_4(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expbinary4_832(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_3>& actual, leaf::parsing::instance::exp_binary_3_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_binary_4(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_binary_4(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_binary_3(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_binary_3> fake;
    exp_binary_3_state state;
    if (!m_expbinary4_832(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expbinary3_ampersand_expbinary4_831(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_binary_3> leaf::parsing::instance::lr_match_exp_binary_3(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_binary_3>();
    std::shared_ptr<leaf::parsing::instance::exp_binary_3> fake;
    exp_binary_3_state state;
    if (!m_expbinary4_832(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expbinary3_ampersand_expbinary4_831(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_binary_3>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expbinary3_ampersand_expbinary4_831(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_expbinary2_circumflex_expbinary3_833(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_2>& actual, leaf::parsing::instance::exp_binary_2_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__circumflex(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_binary_3(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__circumflex(depth + 1).value(), tok::_CIRCUMFLEX);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_binary_3(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expbinary3_834(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_2>& actual, leaf::parsing::instance::exp_binary_2_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_binary_3(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_binary_3(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_binary_2(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_binary_2> fake;
    exp_binary_2_state state;
    if (!m_expbinary3_834(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expbinary2_circumflex_expbinary3_833(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_binary_2> leaf::parsing::instance::lr_match_exp_binary_2(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_binary_2>();
    std::shared_ptr<leaf::parsing::instance::exp_binary_2> fake;
    exp_binary_2_state state;
    if (!m_expbinary3_834(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expbinary2_circumflex_expbinary3_833(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_binary_2>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expbinary2_circumflex_expbinary3_833(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_expbinary1_verticalbar_expbinary2_835(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_1>& actual, leaf::parsing::instance::exp_binary_1_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__vertical_bar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_binary_2(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__vertical_bar(depth + 1).value(), tok::_VERTICAL_BAR);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_binary_2(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expbinary2_836(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_binary_1>& actual, leaf::parsing::instance::exp_binary_1_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_binary_2(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_binary_2(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_binary_1(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_binary_1> fake;
    exp_binary_1_state state;
    if (!m_expbinary2_836(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expbinary1_verticalbar_expbinary2_835(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_binary_1> leaf::parsing::instance::lr_match_exp_binary_1(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_binary_1>();
    std::shared_ptr<leaf::parsing::instance::exp_binary_1> fake;
    exp_binary_1_state state;
    if (!m_expbinary2_836(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expbinary1_verticalbar_expbinary2_835(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_binary_1>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expbinary1_verticalbar_expbinary2_835(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_exparithmetic2_slash_expbinary1_837(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_arithmetic_2>& actual, leaf::parsing::instance::exp_arithmetic_2_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_slash(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_binary_1(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_slash(depth + 1).value(), tok::SLASH);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_binary_1(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_exparithmetic2_star_expbinary1_838(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_arithmetic_2>& actual, leaf::parsing::instance::exp_arithmetic_2_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_star(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_binary_1(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_star(depth + 1).value(), tok::STAR);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_binary_1(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expbinary1_839(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_arithmetic_2>& actual, leaf::parsing::instance::exp_arithmetic_2_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_binary_1(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_binary_1(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_arithmetic_2(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_arithmetic_2> fake;
    exp_arithmetic_2_state state;
    if (!m_expbinary1_839(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_exparithmetic2_slash_expbinary1_837(true, fake, state, depth + 1))
        {
        }
        else if (m_exparithmetic2_star_expbinary1_838(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_arithmetic_2> leaf::parsing::instance::lr_match_exp_arithmetic_2(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_arithmetic_2>();
    std::shared_ptr<leaf::parsing::instance::exp_arithmetic_2> fake;
    exp_arithmetic_2_state state;
    if (!m_expbinary1_839(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_exparithmetic2_slash_expbinary1_837(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_arithmetic_2>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_exparithmetic2_slash_expbinary1_837(false, actual, state, depth + 1);
        }
        else if (m_exparithmetic2_star_expbinary1_838(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_arithmetic_2>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_exparithmetic2_star_expbinary1_838(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_exparithmetic1_plus_exparithmetic2_840(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_arithmetic_1>& actual, leaf::parsing::instance::exp_arithmetic_1_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_plus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_arithmetic_2(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_plus(depth + 1).value(), tok::PLUS);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_arithmetic_2(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_exparithmetic1_minus_exparithmetic2_841(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_arithmetic_1>& actual, leaf::parsing::instance::exp_arithmetic_1_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_minus(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_arithmetic_2(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_minus(depth + 1).value(), tok::MINUS);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_arithmetic_2(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_exparithmetic2_842(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_arithmetic_1>& actual, leaf::parsing::instance::exp_arithmetic_1_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_arithmetic_2(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_arithmetic_2(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_arithmetic_1(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_arithmetic_1> fake;
    exp_arithmetic_1_state state;
    if (!m_exparithmetic2_842(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_exparithmetic1_plus_exparithmetic2_840(true, fake, state, depth + 1))
        {
        }
        else if (m_exparithmetic1_minus_exparithmetic2_841(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_arithmetic_1> leaf::parsing::instance::lr_match_exp_arithmetic_1(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_arithmetic_1>();
    std::shared_ptr<leaf::parsing::instance::exp_arithmetic_1> fake;
    exp_arithmetic_1_state state;
    if (!m_exparithmetic2_842(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_exparithmetic1_plus_exparithmetic2_840(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_arithmetic_1>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_exparithmetic1_plus_exparithmetic2_840(false, actual, state, depth + 1);
        }
        else if (m_exparithmetic1_minus_exparithmetic2_841(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_arithmetic_1>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_exparithmetic1_minus_exparithmetic2_841(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_expcompare_lessthenequal_exparithmetic1_843(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_compare>& actual, leaf::parsing::instance::exp_compare_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_arithmetic_1(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then_equal(depth + 1).value(), tok::_LESS_THEN_EQUAL);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_arithmetic_1(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expcompare_lessthen_exparithmetic1_844(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_compare>& actual, leaf::parsing::instance::exp_compare_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__less_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_arithmetic_1(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__less_then(depth + 1).value(), tok::_LESS_THEN);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_arithmetic_1(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expcompare_greaterthenequal_exparithmetic1_845(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_compare>& actual, leaf::parsing::instance::exp_compare_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_arithmetic_1(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then_equal(depth + 1).value(), tok::_GREATER_THEN_EQUAL);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_arithmetic_1(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expcompare_greaterthen_exparithmetic1_846(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_compare>& actual, leaf::parsing::instance::exp_compare_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__greater_then(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_arithmetic_1(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__greater_then(depth + 1).value(), tok::_GREATER_THEN);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_arithmetic_1(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_exparithmetic1_847(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_compare>& actual, leaf::parsing::instance::exp_compare_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_arithmetic_1(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_arithmetic_1(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_compare(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_compare> fake;
    exp_compare_state state;
    if (!m_exparithmetic1_847(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expcompare_lessthenequal_exparithmetic1_843(true, fake, state, depth + 1))
        {
        }
        else if (m_expcompare_lessthen_exparithmetic1_844(true, fake, state, depth + 1))
        {
        }
        else if (m_expcompare_greaterthenequal_exparithmetic1_845(true, fake, state, depth + 1))
        {
        }
        else if (m_expcompare_greaterthen_exparithmetic1_846(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_compare> leaf::parsing::instance::lr_match_exp_compare(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_compare>();
    std::shared_ptr<leaf::parsing::instance::exp_compare> fake;
    exp_compare_state state;
    if (!m_exparithmetic1_847(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expcompare_lessthenequal_exparithmetic1_843(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_compare>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expcompare_lessthenequal_exparithmetic1_843(false, actual, state, depth + 1);
        }
        else if (m_expcompare_lessthen_exparithmetic1_844(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_compare>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expcompare_lessthen_exparithmetic1_844(false, actual, state, depth + 1);
        }
        else if (m_expcompare_greaterthenequal_exparithmetic1_845(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_compare>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expcompare_greaterthenequal_exparithmetic1_845(false, actual, state, depth + 1);
        }
        else if (m_expcompare_greaterthen_exparithmetic1_846(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_compare>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expcompare_greaterthen_exparithmetic1_846(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_expequality_exclamationequal_expcompare_848(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_equality>& actual, leaf::parsing::instance::exp_equality_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__exclamation_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_compare(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__exclamation_equal(depth + 1).value(), tok::_EXCLAMATION_EQUAL);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_compare(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expequality_equalequalequal_expcompare_849(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_equality>& actual, leaf::parsing::instance::exp_equality_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal_equal_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_compare(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__equal_equal_equal(depth + 1).value(), tok::_EQUAL_EQUAL_EQUAL);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_compare(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expequality_equalequal_expcompare_850(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_equality>& actual, leaf::parsing::instance::exp_equality_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__equal_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_compare(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__equal_equal(depth + 1).value(), tok::_EQUAL_EQUAL);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_compare(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expequality_tildeequal_expcompare_851(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_equality>& actual, leaf::parsing::instance::exp_equality_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__tilde_equal(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_compare(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__tilde_equal(depth + 1).value(), tok::_TILDE_EQUAL);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_compare(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expcompare_852(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_equality>& actual, leaf::parsing::instance::exp_equality_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_compare(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_compare(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_equality(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_equality> fake;
    exp_equality_state state;
    if (!m_expcompare_852(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expequality_exclamationequal_expcompare_848(true, fake, state, depth + 1))
        {
        }
        else if (m_expequality_equalequalequal_expcompare_849(true, fake, state, depth + 1))
        {
        }
        else if (m_expequality_equalequal_expcompare_850(true, fake, state, depth + 1))
        {
        }
        else if (m_expequality_tildeequal_expcompare_851(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_equality> leaf::parsing::instance::lr_match_exp_equality(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_equality>();
    std::shared_ptr<leaf::parsing::instance::exp_equality> fake;
    exp_equality_state state;
    if (!m_expcompare_852(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expequality_exclamationequal_expcompare_848(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_equality>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expequality_exclamationequal_expcompare_848(false, actual, state, depth + 1);
        }
        else if (m_expequality_equalequalequal_expcompare_849(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_equality>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expequality_equalequalequal_expcompare_849(false, actual, state, depth + 1);
        }
        else if (m_expequality_equalequal_expcompare_850(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_equality>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expequality_equalequal_expcompare_850(false, actual, state, depth + 1);
        }
        else if (m_expequality_tildeequal_expcompare_851(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_equality>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expequality_tildeequal_expcompare_851(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_expand_ampersandampersand_expequality_853(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_and>& actual, leaf::parsing::instance::exp_and_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__ampersand_ampersand(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_equality(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__ampersand_ampersand(depth + 1).value(), tok::_AMPERSAND_AMPERSAND);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_equality(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expequality_854(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_and>& actual, leaf::parsing::instance::exp_and_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_equality(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_equality(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_and(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_and> fake;
    exp_and_state state;
    if (!m_expequality_854(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expand_ampersandampersand_expequality_853(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_and> leaf::parsing::instance::lr_match_exp_and(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_and>();
    std::shared_ptr<leaf::parsing::instance::exp_and> fake;
    exp_and_state state;
    if (!m_expequality_854(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expand_ampersandampersand_expequality_853(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_and>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expand_ampersandampersand_expequality_853(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_expor_verticalbarverticalbar_expand_855(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_or>& actual, leaf::parsing::instance::exp_or_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__vertical_bar_vertical_bar(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (lr_can_exp_and(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token__vertical_bar_vertical_bar(depth + 1).value(), tok::_VERTICAL_BAR_VERTICAL_BAR);
    actual->operator_ = val4;
    skip();
    auto val5 = lr_match_exp_and(depth + 1);
    actual->right = val5;
    skip();
    return true;
}
bool leaf::parsing::instance::m_expand_856(bool is_can, std::shared_ptr<leaf::parsing::instance::exp_or>& actual, leaf::parsing::instance::exp_or_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (lr_can_exp_and(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = lr_match_exp_and(depth + 1);
    actual->left = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_exp_or(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::exp_or> fake;
    exp_or_state state;
    if (!m_expand_856(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expor_verticalbarverticalbar_expand_855(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::exp_or> leaf::parsing::instance::lr_match_exp_or(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::exp_or>();
    std::shared_ptr<leaf::parsing::instance::exp_or> fake;
    exp_or_state state;
    if (!m_expand_856(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_expor_verticalbarverticalbar_expand_855(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::exp_or>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_expor_verticalbarverticalbar_expand_855(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_identnavigation_dot_ident_857(bool is_can, std::shared_ptr<leaf::parsing::instance::ident_navigation>& actual, leaf::parsing::instance::ident_navigation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__dot(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__dot(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->right = val8;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_858(bool is_can, std::shared_ptr<leaf::parsing::instance::ident_navigation>& actual, leaf::parsing::instance::ident_navigation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->left = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_ident_navigation(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::ident_navigation> fake;
    ident_navigation_state state;
    if (!m_ident_858(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_identnavigation_dot_ident_857(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::ident_navigation> leaf::parsing::instance::lr_match_ident_navigation(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::ident_navigation>();
    std::shared_ptr<leaf::parsing::instance::ident_navigation> fake;
    ident_navigation_state state;
    if (!m_ident_858(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_identnavigation_dot_ident_857(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::ident_navigation>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_identnavigation_dot_ident_857(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
bool leaf::parsing::instance::m_typenavigation_dot_ident_templateusage_859(bool is_can, std::shared_ptr<leaf::parsing::instance::type_navigation>& actual, leaf::parsing::instance::type_navigation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__dot(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (p_can_template_usage(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__dot(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->right = val8;
    skip();
    auto val9 = p_match_template_usage(depth + 1);
    actual->template_ = val9;
    skip();
    return true;
}
bool leaf::parsing::instance::m_typenavigation_dot_ident_860(bool is_can, std::shared_ptr<leaf::parsing::instance::type_navigation>& actual, leaf::parsing::instance::type_navigation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token__dot(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    auto l4 = token_ident(depth + 1);
    if (l4.has_value())
    {
        for (auto i5 = l4.value(); i5 != 0; i5--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto l7 = token__dot(depth + 1).value();
    for (;l7 != 0; l7--)
    {
        next();
    }
    skip();
    auto val8 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->right = val8;
    skip();
    return true;
}
bool leaf::parsing::instance::m_typenavigation_templateusage_861(bool is_can, std::shared_ptr<leaf::parsing::instance::type_navigation>& actual, leaf::parsing::instance::type_navigation_state& state, size_t depth)
{
    resettable resettable1(*this);
    if (p_can_template_usage(depth + 1))
    {
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val2 = p_match_template_usage(depth + 1);
    actual->template_ = val2;
    skip();
    return true;
}
bool leaf::parsing::instance::m_ident_862(bool is_can, std::shared_ptr<leaf::parsing::instance::type_navigation>& actual, leaf::parsing::instance::type_navigation_state& state, size_t depth)
{
    resettable resettable1(*this);
    auto l2 = token_ident(depth + 1);
    if (l2.has_value())
    {
        for (auto i3 = l2.value(); i3 != 0; i3--)
        {
            next();
        }
        skip();
    }
    else if (is_can)
    {
        resettable1.reset();
        return false;
    }
    else
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return false;
    }
    if (is_can)
    {
        return true;
    }
    resettable1.reset();
    auto val4 = create_token(token_ident(depth + 1).value(), tok::IDENT);
    actual->left = val4;
    skip();
    return true;
}
bool leaf::parsing::instance::lr_can_type_navigation(size_t depth)
{
    resettable resettable1(*this);
    std::shared_ptr<leaf::parsing::instance::type_navigation> fake;
    type_navigation_state state;
    if (!m_ident_862(true, fake, state, depth + 1))
    {
        return false;
    }
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_typenavigation_dot_ident_templateusage_859(true, fake, state, depth + 1))
        {
        }
        else if (m_typenavigation_dot_ident_860(true, fake, state, depth + 1))
        {
        }
        else if (m_typenavigation_templateusage_861(true, fake, state, depth + 1))
        {
        }
        else
        {
            return true;
        }
    }
}
std::shared_ptr<leaf::parsing::instance::type_navigation> leaf::parsing::instance::lr_match_type_navigation(size_t depth)
{
    auto actual = std::make_shared<leaf::parsing::instance::type_navigation>();
    std::shared_ptr<leaf::parsing::instance::type_navigation> fake;
    type_navigation_state state;
    if (!m_ident_862(false, actual, state, depth + 1))
    {
        report("Something moved wrong (todo: improve error messages)", depth);
        return {};
    }
    bool is_first2 = true;
    while (true)
    {
        skip();
        resettable resettable1(*this);
        if (m_typenavigation_dot_ident_templateusage_859(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::type_navigation>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_typenavigation_dot_ident_templateusage_859(false, actual, state, depth + 1);
        }
        else if (m_typenavigation_dot_ident_860(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::type_navigation>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_typenavigation_dot_ident_860(false, actual, state, depth + 1);
        }
        else if (m_typenavigation_templateusage_861(true, fake, state, depth + 1))
        {
            resettable1.reset();
            if (!is_first2)
            {
                auto tmp_actual3 = actual;
                actual = std::make_shared<leaf::parsing::instance::type_navigation>();
                actual->left = tmp_actual3;
            }
            is_first2 = false;
            m_typenavigation_templateusage_861(false, actual, state, depth + 1);
        }
        else
        {
            resettable1.reset();
            break;
        }
    }
    return actual;
}
void leaf::parsing::instance::skip()
{
    while (m_contents.length() > m_offset)
    {
        char c = m_contents[m_offset];
        switch (c)
        {
            case '\r':
            case '\t':
            case ' ': m_column++; m_offset++; break;
            case '\n': m_line++; m_column = 1; m_offset++; break;
            default:
            {
                bool wasMatched1 = false;
                if (m_contents.length() > m_offset + 2 && m_contents[m_offset + 0] == '/' && m_contents[m_offset + 1] == '/')
                {
                    wasMatched1 = true;
                    for (size_t i2 = 0; i2 < 2; i2++)
                    {
                        switch (m_contents[m_offset])
                        {
                            case '\r':
                            case '\t':
                            case ' ': m_column++; m_offset++; break;
                            case '\n': m_line++; m_column = 1; m_offset++; break;
                            default: m_column++; m_offset++; break;
                        }
                    }
                    while (m_contents.length() > m_offset + 2 && !(m_contents[m_offset + 0] == '\n'))
                    {
                        switch (m_contents[m_offset])
                        {
                            case '\r':
                            case '\t':
                            case ' ': m_column++; m_offset++; break;
                            case '\n': m_line++; m_column = 1; m_offset++; break;
                            default: m_column++; m_offset++; break;
                        }
                    }
                    for (size_t i2 = 0; i2 < 1; i2++)
                    {
                        switch (m_contents[m_offset])
                        {
                            case '\r':
                            case '\t':
                            case ' ': m_column++; m_offset++; break;
                            case '\n': m_line++; m_column = 1; m_offset++; break;
                            default: m_column++; m_offset++; break;
                        }
                    }
                }
                if (m_contents.length() > m_offset + 2 && m_contents[m_offset + 0] == '/' && m_contents[m_offset + 1] == '*')
                {
                    wasMatched1 = true;
                    for (size_t i3 = 0; i3 < 2; i3++)
                    {
                        switch (m_contents[m_offset])
                        {
                            case '\r':
                            case '\t':
                            case ' ': m_column++; m_offset++; break;
                            case '\n': m_line++; m_column = 1; m_offset++; break;
                            default: m_column++; m_offset++; break;
                        }
                    }
                    while (m_contents.length() > m_offset + 2 && !(m_contents[m_offset + 0] == '*' && m_contents[m_offset + 1] == '/'))
                    {
                        switch (m_contents[m_offset])
                        {
                            case '\r':
                            case '\t':
                            case ' ': m_column++; m_offset++; break;
                            case '\n': m_line++; m_column = 1; m_offset++; break;
                            default: m_column++; m_offset++; break;
                        }
                    }
                    for (size_t i3 = 0; i3 < 2; i3++)
                    {
                        switch (m_contents[m_offset])
                        {
                            case '\r':
                            case '\t':
                            case ' ': m_column++; m_offset++; break;
                            case '\n': m_line++; m_column = 1; m_offset++; break;
                            default: m_column++; m_offset++; break;
                        }
                    }
                }
                if (!wasMatched1)
                {
                    return;
                }
            }
        }
    }
}
void leaf::parsing::instance::report(std::string_view message, size_t depth)
{
    std::cout << "[L" << m_line << "]" << "[C" << m_column << "] " << message << "\n";
}
leaf::parsing::instance::token leaf::parsing::instance::create_token(size_t length, tok type)
{
    token t;
    t.file = m_file;
    t.line = m_line;
    t.column = m_column;
    t.offset = m_offset;
    t.length = length;
    t.type = type;
    for (auto i = 0; i < length; i++)
    {
        next();
    }
    return t;
}
std::shared_ptr<leaf::parsing::instance::main> leaf::parsing::instance::parse()
{
    skip();
    return p_match_main(0);
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<attribute_arg_item_a> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("attribute_arg_item_a:");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<attribute_arg_item_b> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("attribute_arg_item_b:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<attribute_args_a> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("attribute_args_a:");
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<attribute_args_b> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("attribute_args_b:");
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<attribute_item> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("attribute_item:");
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    switch (node->args.index())
    {
        case 0:
        if (std::get<std::shared_ptr<attribute_args_a>>(node->args))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<attribute_args_a>>(node->args), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<attribute_args_b>>(node->args))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<attribute_args_b>>(node->args), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<attribute> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("attribute:");
    for (auto element : node->items)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [items]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract:");
    if (node->scope)
    {
        auto lines = create_string_tree(node->scope, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [scope]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_method> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_method:");
    if (node->return_type)
    {
        auto lines = create_string_tree(node->return_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [return_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->arglist)
    {
        auto lines = create_string_tree(node->arglist, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [arglist]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_constructor> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_constructor:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->arglist)
    {
        auto lines = create_string_tree(node->arglist, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [arglist]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_indexer> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_indexer:");
    if (node->is_set.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_set.value()));
    }
    if (node->is_get.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_get.value()));
    }
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->arglist)
    {
        auto lines = create_string_tree(node->arglist, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [arglist]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_operator_binary_overload> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_operator_binary_overload:");
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->left)
    {
        auto lines = create_string_tree(node->left, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_operator_unary_overload> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_operator_unary_overload:");
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_operator_nullar_overload> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_operator_nullar_overload:");
    if (node->meta)
    {
        auto lines = create_string_tree(node->meta, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [meta]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_property> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_property:");
    if (node->is_set.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_set.value()));
    }
    if (node->is_get.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_get.value()));
    }
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_field> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_field:");
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_method_arglist> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_method_arglist:");
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<contract_method_arglist_indexer> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("contract_method_arglist_indexer:");
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<scope> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("scope:");
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [usings]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->body)
    {
        switch (element.index())
        {
            case 0:
            if (std::get<std::shared_ptr<control_structure>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<control_structure>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
            case 1:
            if (std::get<std::shared_ptr<statement>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<statement>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<scope_lambda> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("scope_lambda:");
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [usings]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->body)
    {
        switch (element.index())
        {
            case 0:
            if (std::get<std::shared_ptr<control_structure>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<control_structure>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
            case 1:
            if (std::get<std::shared_ptr<statement>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<statement>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<scope_getset> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("scope_getset:");
    if (node->get)
    {
        auto lines = create_string_tree(node->get, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [get]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->set)
    {
        auto lines = create_string_tree(node->set, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [set]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<control_structure_body> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("control_structure_body:");
    switch (node->body.index())
    {
        case 0:
        if (std::get<std::shared_ptr<scope>>(node->body))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<scope>>(node->body), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<control_structure>>(node->body))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<control_structure>>(node->body), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 2:
        if (std::get<std::shared_ptr<statement>>(node->body))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<statement>>(node->body), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<while_loop> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("while_loop:");
    if (node->condition)
    {
        auto lines = create_string_tree(node->condition, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [condition]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<if_body> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("if_body:");
    if (node->condition)
    {
        auto lines = create_string_tree(node->condition, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [condition]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<else_body> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("else_body:");
    if (node->else_body)
    {
        auto lines = create_string_tree(node->else_body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [else_body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<for_body> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("for_body:");
    if (node->pre)
    {
        auto lines = create_string_tree(node->pre, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [pre]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->condition)
    {
        auto lines = create_string_tree(node->condition, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [condition]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->post_inner)
    {
        auto lines = create_string_tree(node->post_inner, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [post_inner]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<for_each_body> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("for_each_body:");
    if (node->pre)
    {
        auto lines = create_string_tree(node->pre, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [pre]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->exp)
    {
        auto lines = create_string_tree(node->exp, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [exp]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<if_else> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("if_else:");
    if (node->if_)
    {
        auto lines = create_string_tree(node->if_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [if_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->else_)
    {
        auto lines = create_string_tree(node->else_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [else_]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<switch_case> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("switch_case:");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<switch_> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("switch_:");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    for (auto element : node->part)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [part]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->default_body)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [default_body]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->pragmas)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [pragmas]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<assembly_terminate> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("assembly_terminate:");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<assembly> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("assembly:");
    for (auto element : node->args)
    {
        output.push_back(std::string("  ") + "token (L" + std::to_string(element.line) + "; C" + std::to_string(element.column) + "; O" + std::to_string(element.offset) + ") `" + std::string(contents.substr(element.offset, element.length).begin(), contents.substr(element.offset, element.length).end()) + "`");
    }
    for (auto element : node->opcode)
    {
        output.push_back(std::string("  ") + "token (L" + std::to_string(element.line) + "; C" + std::to_string(element.column) + "; O" + std::to_string(element.offset) + ") `" + std::string(contents.substr(element.offset, element.length).begin(), contents.substr(element.offset, element.length).end()) + "`");
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<control_structure> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("control_structure:");
    if (node->pragmas)
    {
        auto lines = create_string_tree(node->pragmas, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [pragmas]" "\u001b[0m" : line));
            first = false;
        }
    }
    switch (node->content.index())
    {
        case 0:
        if (std::get<std::shared_ptr<while_loop>>(node->content))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<while_loop>>(node->content), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [content]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<for_body>>(node->content))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<for_body>>(node->content), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [content]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 2:
        if (std::get<std::shared_ptr<for_each_body>>(node->content))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<for_each_body>>(node->content), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [content]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 3:
        if (std::get<std::shared_ptr<if_else>>(node->content))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<if_else>>(node->content), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [content]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 4:
        if (std::get<std::shared_ptr<switch_>>(node->content))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<switch_>>(node->content), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [content]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 5:
        if (std::get<std::shared_ptr<scope>>(node->content))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<scope>>(node->content), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [content]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 6:
        if (std::get<std::shared_ptr<assembly>>(node->content))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<assembly>>(node->content), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [content]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_chain_start> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_chain_start:");
    if (node->part_alloc)
    {
        auto lines = create_string_tree(node->part_alloc, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [part_alloc]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->part_free)
    {
        auto lines = create_string_tree(node->part_free, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [part_free]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->part_call)
    {
        auto lines = create_string_tree(node->part_call, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [part_call]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->part_ident.line) + "; C" + std::to_string(node->part_ident.column) + "; O" + std::to_string(node->part_ident.offset) + ") `" + std::string(contents.substr(node->part_ident.offset, node->part_ident.length).begin(), contents.substr(node->part_ident.offset, node->part_ident.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_constant> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_constant:");
    if (node->typeof_)
    {
        auto lines = create_string_tree(node->typeof_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [typeof_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->nameof)
    {
        auto lines = create_string_tree(node->nameof, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [nameof]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->sizeof_)
    {
        auto lines = create_string_tree(node->sizeof_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [sizeof_]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->t.line) + "; C" + std::to_string(node->t.column) + "; O" + std::to_string(node->t.offset) + ") `" + std::string(contents.substr(node->t.offset, node->t.length).begin(), contents.substr(node->t.offset, node->t.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_lambda> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_lambda:");
    if (node->capture)
    {
        auto lines = create_string_tree(node->capture, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [capture]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->args)
    {
        auto lines = create_string_tree(node->args, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->scope)
    {
        auto lines = create_string_tree(node->scope, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [scope]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<capture_list_item> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("capture_list_item:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->capture_type.line) + "; C" + std::to_string(node->capture_type.column) + "; O" + std::to_string(node->capture_type.offset) + ") `" + std::string(contents.substr(node->capture_type.offset, node->capture_type.length).begin(), contents.substr(node->capture_type.offset, node->capture_type.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->variable.line) + "; C" + std::to_string(node->variable.column) + "; O" + std::to_string(node->variable.offset) + ") `" + std::string(contents.substr(node->variable.offset, node->variable.length).begin(), contents.substr(node->variable.offset, node->variable.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<capture_list> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("capture_list:");
    for (auto element : node->items)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [items]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_value> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_value:");
    if (node->exp_lambda)
    {
        auto lines = create_string_tree(node->exp_lambda, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [exp_lambda]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->exp_constant)
    {
        auto lines = create_string_tree(node->exp_constant, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [exp_constant]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->scalar)
    {
        auto lines = create_string_tree(node->scalar, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [scalar]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->integer_hex)
    {
        auto lines = create_string_tree(node->integer_hex, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [integer_hex]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->integer_binary)
    {
        auto lines = create_string_tree(node->integer_binary, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [integer_binary]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->integer)
    {
        auto lines = create_string_tree(node->integer, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [integer]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->character)
    {
        auto lines = create_string_tree(node->character, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [character]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->string)
    {
        auto lines = create_string_tree(node->string, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [string]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->constant)
    {
        auto lines = create_string_tree(node->constant, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [constant]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_nullar> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_nullar:");
    switch (node->value.index())
    {
        case 0:
        if (std::get<std::shared_ptr<expression>>(node->value))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<expression>>(node->value), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_chain>>(node->value))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_chain>>(node->value), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 2:
        if (std::get<std::shared_ptr<exp_value>>(node->value))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_value>>(node->value), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_unary> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_unary:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    switch (node->value.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_unary>>(node->value))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_unary>>(node->value), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_nullar>>(node->value))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_nullar>>(node->value), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    if (node->cast_target)
    {
        auto lines = create_string_tree(node->cast_target, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [cast_target]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<expression> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("expression:");
    if (node->assign_to)
    {
        auto lines = create_string_tree(node->assign_to, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [assign_to]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->exp)
    {
        auto lines = create_string_tree(node->exp, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [exp]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<encapsulation> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("encapsulation:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->tok.line) + "; C" + std::to_string(node->tok.column) + "; O" + std::to_string(node->tok.offset) + ") `" + std::string(contents.substr(node->tok.offset, node->tok.length).begin(), contents.substr(node->tok.offset, node->tok.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<namespace_> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("namespace_:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->name)
    {
        auto lines = create_string_tree(node->name, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [name]" "\u001b[0m" : line));
            first = false;
        }
    }
    for (auto element : node->contracts)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [contracts]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->aliases)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [aliases]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->constants)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [constants]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [usings]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->namespaces)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [namespaces]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->conversions)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [conversions]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->classes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [classes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->methods)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [methods]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->properties)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [properties]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->fields)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [fields]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->pragmas)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [pragmas]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<class_> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("class_:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->scope)
    {
        auto lines = create_string_tree(node->scope, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [scope]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->lifetime)
    {
        auto lines = create_string_tree(node->lifetime, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [lifetime]" "\u001b[0m" : line));
            first = false;
        }
    }
    for (auto element : node->contracts)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [contracts]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->aliases)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [aliases]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->constants)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [constants]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [usings]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->indexers)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [indexers]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->operators_binary)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [operators_binary]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->operators_unary)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [operators_unary]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->operators_nullar)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [operators_nullar]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->conversions)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [conversions]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->classes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [classes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->constructors)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [constructors]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->destructors)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [destructors]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->copystructors)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [copystructors]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->properties)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [properties]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->fields)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [fields]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->methods)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [methods]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->pragmas)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [pragmas]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<method_arglist_item> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("method_arglist_item:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->type)
    {
        auto lines = create_string_tree(node->type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<method_arglist> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("method_arglist:");
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<method_arglist_indexer> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("method_arglist_indexer:");
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<method_meta> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("method_meta:");
    if (node->is_sealed.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_sealed.value()));
    }
    if (node->is_virtual.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_virtual.value()));
    }
    if (node->is_static.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_static.value()));
    }
    if (node->is_inline.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_inline.value()));
    }
    if (node->encaps)
    {
        auto lines = create_string_tree(node->encaps, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [encaps]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<method> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("method:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->meta)
    {
        auto lines = create_string_tree(node->meta, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [meta]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->return_type)
    {
        auto lines = create_string_tree(node->return_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [return_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->arglist)
    {
        auto lines = create_string_tree(node->arglist, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [arglist]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<constructor> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("constructor:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->encaps)
    {
        auto lines = create_string_tree(node->encaps, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [encaps]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->arglist)
    {
        auto lines = create_string_tree(node->arglist, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [arglist]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<destructor> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("destructor:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->encaps)
    {
        auto lines = create_string_tree(node->encaps, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [encaps]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->arglist)
    {
        auto lines = create_string_tree(node->arglist, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [arglist]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<copystructor> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("copystructor:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->encaps)
    {
        auto lines = create_string_tree(node->encaps, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [encaps]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->arglist)
    {
        auto lines = create_string_tree(node->arglist, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [arglist]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<conversion> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("conversion:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->meta)
    {
        auto lines = create_string_tree(node->meta, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [meta]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->source_type)
    {
        auto lines = create_string_tree(node->source_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [source_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<indexer> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("indexer:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->meta)
    {
        auto lines = create_string_tree(node->meta, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [meta]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->arglist)
    {
        auto lines = create_string_tree(node->arglist, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [arglist]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<operator_binary_overload> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("operator_binary_overload:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->meta)
    {
        auto lines = create_string_tree(node->meta, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [meta]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->left)
    {
        auto lines = create_string_tree(node->left, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<operator_unary_overload> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("operator_unary_overload:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->meta)
    {
        auto lines = create_string_tree(node->meta, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [meta]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<operator_nullar_overload> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("operator_nullar_overload:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->meta)
    {
        auto lines = create_string_tree(node->meta, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [meta]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<property> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("property:");
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->meta)
    {
        auto lines = create_string_tree(node->meta, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [meta]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<field> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("field:");
    if (node->is_static.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_static.value()));
    }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [attributes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    if (node->encaps)
    {
        auto lines = create_string_tree(node->encaps, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [encaps]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<constant> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("constant:");
    if (node->target_type)
    {
        auto lines = create_string_tree(node->target_type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [target_type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<using_> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("using_:");
    if (node->is_namespace.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_namespace.value()));
    }
    if (node->is_class.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_class.value()));
    }
    if (node->ident)
    {
        auto lines = create_string_tree(node->ident, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [ident]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->alias.line) + "; C" + std::to_string(node->alias.column) + "; O" + std::to_string(node->alias.offset) + ") `" + std::string(contents.substr(node->alias.offset, node->alias.length).begin(), contents.substr(node->alias.offset, node->alias.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<alias_encapsulated> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("alias_encapsulated:");
    if (node->encaps)
    {
        auto lines = create_string_tree(node->encaps, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [encaps]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->actual)
    {
        auto lines = create_string_tree(node->actual, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [actual]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<alias> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("alias:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->alias.line) + "; C" + std::to_string(node->alias.column) + "; O" + std::to_string(node->alias.offset) + ") `" + std::string(contents.substr(node->alias.offset, node->alias.length).begin(), contents.substr(node->alias.offset, node->alias.length).end()) + "`");
    if (node->ident)
    {
        auto lines = create_string_tree(node->ident, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [ident]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<call> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("call:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->method.line) + "; C" + std::to_string(node->method.column) + "; O" + std::to_string(node->method.offset) + ") `" + std::string(contents.substr(node->method.offset, node->method.length).begin(), contents.substr(node->method.offset, node->method.length).end()) + "`");
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<call_body> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("call_body:");
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [args]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<free> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("free:");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<alloc> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("alloc:");
    if (node->is_stack.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_stack.value()));
    }
    if (node->is_heap.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_heap.value()));
    }
    if (node->type)
    {
        auto lines = create_string_tree(node->type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [type]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->exp)
    {
        auto lines = create_string_tree(node->exp, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [exp]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->body)
    {
        auto lines = create_string_tree(node->body, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [body]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<typeof_> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("typeof_:");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<nameof> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("nameof:");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<sizeof_> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("sizeof_:");
    if (node->type)
    {
        auto lines = create_string_tree(node->type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [type]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<lifetime> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("lifetime:");
    if (node->is_scope.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_scope.value()));
    }
    if (node->is_static.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_static.value()));
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->named.line) + "; C" + std::to_string(node->named.column) + "; O" + std::to_string(node->named.offset) + ") `" + std::string(contents.substr(node->named.offset, node->named.length).begin(), contents.substr(node->named.offset, node->named.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<type_match> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("type_match:");
    if (node->is_array.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_array.value()));
    }
    if (node->is_heap.has_value())
    {
        output.push_back(std::string("  ") + std::to_string(node->is_heap.value()));
    }
    if (node->base)
    {
        auto lines = create_string_tree(node->base, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [base]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->lifetime)
    {
        auto lines = create_string_tree(node->lifetime, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [lifetime]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<string_formatable> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("string_formatable:");
    for (auto element : node->parts)
    {
        switch (element.index())
        {
            case 0:
            output.push_back(std::string("  ") + "token (L" + std::to_string(std::get<token>(element).line) + "; C" + std::to_string(std::get<token>(element).column) + "; O" + std::to_string(std::get<token>(element).offset) + ") `" + std::string(contents.substr(std::get<token>(element).offset, std::get<token>(element).length).begin(), contents.substr(std::get<token>(element).offset, std::get<token>(element).length).end()) + "`");
            break;
            case 1:
            if (std::get<std::shared_ptr<expression>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<expression>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [parts]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<string_literal> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("string_literal:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->prefix.line) + "; C" + std::to_string(node->prefix.column) + "; O" + std::to_string(node->prefix.offset) + ") `" + std::string(contents.substr(node->prefix.offset, node->prefix.length).begin(), contents.substr(node->prefix.offset, node->prefix.length).end()) + "`");
    switch (node->value.index())
    {
        case 0:
        if (std::get<std::shared_ptr<string_formatable>>(node->value))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<string_formatable>>(node->value), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        output.push_back(std::string("  ") + "token (L" + std::to_string(std::get<token>(node->value).line) + "; C" + std::to_string(std::get<token>(node->value).column) + "; O" + std::to_string(std::get<token>(node->value).offset) + ") `" + std::string(contents.substr(std::get<token>(node->value).offset, std::get<token>(node->value).length).begin(), contents.substr(std::get<token>(node->value).offset, std::get<token>(node->value).length).end()) + "`");
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->postfix.line) + "; C" + std::to_string(node->postfix.column) + "; O" + std::to_string(node->postfix.offset) + ") `" + std::string(contents.substr(node->postfix.offset, node->postfix.length).begin(), contents.substr(node->postfix.offset, node->postfix.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<scalar_literal> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("scalar_literal:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->prefix.line) + "; C" + std::to_string(node->prefix.column) + "; O" + std::to_string(node->prefix.offset) + ") `" + std::string(contents.substr(node->prefix.offset, node->prefix.length).begin(), contents.substr(node->prefix.offset, node->prefix.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->value.line) + "; C" + std::to_string(node->value.column) + "; O" + std::to_string(node->value.offset) + ") `" + std::string(contents.substr(node->value.offset, node->value.length).begin(), contents.substr(node->value.offset, node->value.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->postfix.line) + "; C" + std::to_string(node->postfix.column) + "; O" + std::to_string(node->postfix.offset) + ") `" + std::string(contents.substr(node->postfix.offset, node->postfix.length).begin(), contents.substr(node->postfix.offset, node->postfix.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<integer_hex_literal> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("integer_hex_literal:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->prefix.line) + "; C" + std::to_string(node->prefix.column) + "; O" + std::to_string(node->prefix.offset) + ") `" + std::string(contents.substr(node->prefix.offset, node->prefix.length).begin(), contents.substr(node->prefix.offset, node->prefix.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->value.line) + "; C" + std::to_string(node->value.column) + "; O" + std::to_string(node->value.offset) + ") `" + std::string(contents.substr(node->value.offset, node->value.length).begin(), contents.substr(node->value.offset, node->value.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->postfix.line) + "; C" + std::to_string(node->postfix.column) + "; O" + std::to_string(node->postfix.offset) + ") `" + std::string(contents.substr(node->postfix.offset, node->postfix.length).begin(), contents.substr(node->postfix.offset, node->postfix.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<integer_binary_literal> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("integer_binary_literal:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->prefix.line) + "; C" + std::to_string(node->prefix.column) + "; O" + std::to_string(node->prefix.offset) + ") `" + std::string(contents.substr(node->prefix.offset, node->prefix.length).begin(), contents.substr(node->prefix.offset, node->prefix.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->value.line) + "; C" + std::to_string(node->value.column) + "; O" + std::to_string(node->value.offset) + ") `" + std::string(contents.substr(node->value.offset, node->value.length).begin(), contents.substr(node->value.offset, node->value.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->postfix.line) + "; C" + std::to_string(node->postfix.column) + "; O" + std::to_string(node->postfix.offset) + ") `" + std::string(contents.substr(node->postfix.offset, node->postfix.length).begin(), contents.substr(node->postfix.offset, node->postfix.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<integer_literal> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("integer_literal:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->prefix.line) + "; C" + std::to_string(node->prefix.column) + "; O" + std::to_string(node->prefix.offset) + ") `" + std::string(contents.substr(node->prefix.offset, node->prefix.length).begin(), contents.substr(node->prefix.offset, node->prefix.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->value.line) + "; C" + std::to_string(node->value.column) + "; O" + std::to_string(node->value.offset) + ") `" + std::string(contents.substr(node->value.offset, node->value.length).begin(), contents.substr(node->value.offset, node->value.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->postfix.line) + "; C" + std::to_string(node->postfix.column) + "; O" + std::to_string(node->postfix.offset) + ") `" + std::string(contents.substr(node->postfix.offset, node->postfix.length).begin(), contents.substr(node->postfix.offset, node->postfix.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<char_literal> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("char_literal:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->prefix.line) + "; C" + std::to_string(node->prefix.column) + "; O" + std::to_string(node->prefix.offset) + ") `" + std::string(contents.substr(node->prefix.offset, node->prefix.length).begin(), contents.substr(node->prefix.offset, node->prefix.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->value.line) + "; C" + std::to_string(node->value.column) + "; O" + std::to_string(node->value.offset) + ") `" + std::string(contents.substr(node->value.offset, node->value.length).begin(), contents.substr(node->value.offset, node->value.length).end()) + "`");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->postfix.line) + "; C" + std::to_string(node->postfix.column) + "; O" + std::to_string(node->postfix.offset) + ") `" + std::string(contents.substr(node->postfix.offset, node->postfix.length).begin(), contents.substr(node->postfix.offset, node->postfix.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<declaration> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("declaration:");
    if (node->type)
    {
        auto lines = create_string_tree(node->type, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [type]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->name.line) + "; C" + std::to_string(node->name.column) + "; O" + std::to_string(node->name.offset) + ") `" + std::string(contents.substr(node->name.offset, node->name.length).begin(), contents.substr(node->name.offset, node->name.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<return_statement> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("return_statement:");
    if (node->exp)
    {
        auto lines = create_string_tree(node->exp, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [exp]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<statement> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("statement:");
    if (node->aliases)
    {
        auto lines = create_string_tree(node->aliases, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [aliases]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->constants)
    {
        auto lines = create_string_tree(node->constants, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [constants]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->ret)
    {
        auto lines = create_string_tree(node->ret, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [ret]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->fwrd_decl)
    {
        auto lines = create_string_tree(node->fwrd_decl, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [fwrd_decl]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->exp)
    {
        auto lines = create_string_tree(node->exp, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [exp]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->pragma)
    {
        auto lines = create_string_tree(node->pragma, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [pragma]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<pragma> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("pragma:");
    for (auto element : node->contents)
    {
        switch (element.index())
        {
            case 0:
            if (std::get<std::shared_ptr<pragma_disable>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<pragma_disable>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [contents]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
            case 1:
            if (std::get<std::shared_ptr<pragma_enable>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<pragma_enable>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [contents]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
            case 2:
            if (std::get<std::shared_ptr<pragma_size>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<pragma_size>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [contents]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
            case 3:
            if (std::get<std::shared_ptr<pragma_align>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<pragma_align>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [contents]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<pragma_align> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("pragma_align:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->bytes.line) + "; C" + std::to_string(node->bytes.column) + "; O" + std::to_string(node->bytes.offset) + ") `" + std::string(contents.substr(node->bytes.offset, node->bytes.length).begin(), contents.substr(node->bytes.offset, node->bytes.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<pragma_size> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("pragma_size:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->bytes.line) + "; C" + std::to_string(node->bytes.column) + "; O" + std::to_string(node->bytes.offset) + ") `" + std::string(contents.substr(node->bytes.offset, node->bytes.length).begin(), contents.substr(node->bytes.offset, node->bytes.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<pragma_disable> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("pragma_disable:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->code.line) + "; C" + std::to_string(node->code.column) + "; O" + std::to_string(node->code.offset) + ") `" + std::string(contents.substr(node->code.offset, node->code.length).begin(), contents.substr(node->code.offset, node->code.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<pragma_enable> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("pragma_enable:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->code.line) + "; C" + std::to_string(node->code.column) + "; O" + std::to_string(node->code.offset) + ") `" + std::string(contents.substr(node->code.offset, node->code.length).begin(), contents.substr(node->code.offset, node->code.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<template_usage_item> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("template_usage_item:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->key.line) + "; C" + std::to_string(node->key.column) + "; O" + std::to_string(node->key.offset) + ") `" + std::string(contents.substr(node->key.offset, node->key.length).begin(), contents.substr(node->key.offset, node->key.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<template_usage> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("template_usage:");
    for (auto element : node->items)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [items]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<template_definition_item_direct_type> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("template_definition_item_direct_type:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->key.line) + "; C" + std::to_string(node->key.column) + "; O" + std::to_string(node->key.offset) + ") `" + std::string(contents.substr(node->key.offset, node->key.length).begin(), contents.substr(node->key.offset, node->key.length).end()) + "`");
    if (node->value)
    {
        auto lines = create_string_tree(node->value, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [value]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<template_definition_item_identifier> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("template_definition_item_identifier:");
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->key.line) + "; C" + std::to_string(node->key.column) + "; O" + std::to_string(node->key.offset) + ") `" + std::string(contents.substr(node->key.offset, node->key.length).begin(), contents.substr(node->key.offset, node->key.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<template_definition> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("template_definition:");
    for (auto element : node->items)
    {
        switch (element.index())
        {
            case 0:
            if (std::get<std::shared_ptr<template_definition_item_identifier>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<template_definition_item_identifier>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [items]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
            case 1:
            if (std::get<std::shared_ptr<template_definition_item_direct_type>>(element))
            {
                auto lines = create_string_tree(std::get<std::shared_ptr<template_definition_item_direct_type>>(element), contents);
                bool first = true;
                for (auto line : lines)
                {
                    output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [items]" "\u001b[0m" : line));
                    first = false;
                }
            }
            break;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<main> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("main:");
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [usings]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->contract)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [contract]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->aliases)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [aliases]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->namespaces)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [namespaces]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->conversions)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [conversions]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->classes)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [classes]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->methods)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [methods]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->properties)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [properties]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->fields)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [fields]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    for (auto element : node->pragmas)
    {
        if (element)
        {
            auto lines = create_string_tree(element, contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [pragmas]" "\u001b[0m" : line));
                first = false;
            }
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_chain> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_chain:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_chain>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_chain>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_chain_start>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_chain_start>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    if (node->chain_call)
    {
        auto lines = create_string_tree(node->chain_call, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [chain_call]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->chain_access.line) + "; C" + std::to_string(node->chain_access.column) + "; O" + std::to_string(node->chain_access.offset) + ") `" + std::string(contents.substr(node->chain_access.offset, node->chain_access.length).begin(), contents.substr(node->chain_access.offset, node->chain_access.length).end()) + "`");
    if (node->indirection_call)
    {
        auto lines = create_string_tree(node->indirection_call, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [indirection_call]" "\u001b[0m" : line));
            first = false;
        }
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->indirection_access.line) + "; C" + std::to_string(node->indirection_access.column) + "; O" + std::to_string(node->indirection_access.offset) + ") `" + std::string(contents.substr(node->indirection_access.offset, node->indirection_access.length).begin(), contents.substr(node->indirection_access.offset, node->indirection_access.length).end()) + "`");
    if (node->chain_indexer)
    {
        auto lines = create_string_tree(node->chain_indexer, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [chain_indexer]" "\u001b[0m" : line));
            first = false;
        }
    }
    if (node->chain_template)
    {
        auto lines = create_string_tree(node->chain_template, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [chain_template]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_binary_4> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_binary_4:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_binary_4>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_binary_4>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_unary>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_unary>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_binary_3> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_binary_3:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_binary_3>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_binary_3>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_binary_4>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_binary_4>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_binary_2> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_binary_2:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_binary_2>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_binary_2>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_binary_3>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_binary_3>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_binary_1> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_binary_1:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_binary_1>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_binary_1>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_binary_2>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_binary_2>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_arithmetic_2> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_arithmetic_2:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_arithmetic_2>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_arithmetic_2>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_binary_1>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_binary_1>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_arithmetic_1> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_arithmetic_1:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_arithmetic_1>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_arithmetic_1>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_arithmetic_2>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_arithmetic_2>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_compare> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_compare:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_compare>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_compare>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_arithmetic_1>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_arithmetic_1>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_equality> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_equality:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_equality>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_equality>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_compare>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_compare>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_and> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_and:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_and>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_and>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_equality>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_equality>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<exp_or> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("exp_or:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_or>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_or>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_and>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<exp_and>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->operator_.line) + "; C" + std::to_string(node->operator_.column) + "; O" + std::to_string(node->operator_.offset) + ") `" + std::string(contents.substr(node->operator_.offset, node->operator_.length).begin(), contents.substr(node->operator_.offset, node->operator_.length).end()) + "`");
    if (node->right)
    {
        auto lines = create_string_tree(node->right, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [right]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<ident_navigation> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("ident_navigation:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<ident_navigation>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<ident_navigation>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        output.push_back(std::string("  ") + "token (L" + std::to_string(std::get<token>(node->left).line) + "; C" + std::to_string(std::get<token>(node->left).column) + "; O" + std::to_string(std::get<token>(node->left).offset) + ") `" + std::string(contents.substr(std::get<token>(node->left).offset, std::get<token>(node->left).length).begin(), contents.substr(std::get<token>(node->left).offset, std::get<token>(node->left).length).end()) + "`");
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->right.line) + "; C" + std::to_string(node->right.column) + "; O" + std::to_string(node->right.offset) + ") `" + std::string(contents.substr(node->right.offset, node->right.length).begin(), contents.substr(node->right.offset, node->right.length).end()) + "`");
    return output;
}
std::vector<std::string> leaf::parsing::instance::create_string_tree(std::shared_ptr<type_navigation> node, std::string_view contents)
{
    std::vector<std::string> output;
    output.push_back("type_navigation:");
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<type_navigation>>(node->left))
        {
            auto lines = create_string_tree(std::get<std::shared_ptr<type_navigation>>(node->left), contents);
            bool first = true;
            for (auto line : lines)
            {
                output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [left]" "\u001b[0m" : line));
                first = false;
            }
        }
        break;
        case 1:
        output.push_back(std::string("  ") + "token (L" + std::to_string(std::get<token>(node->left).line) + "; C" + std::to_string(std::get<token>(node->left).column) + "; O" + std::to_string(std::get<token>(node->left).offset) + ") `" + std::string(contents.substr(std::get<token>(node->left).offset, std::get<token>(node->left).length).begin(), contents.substr(std::get<token>(node->left).offset, std::get<token>(node->left).length).end()) + "`");
        break;
    }
    output.push_back(std::string("  ") + "token (L" + std::to_string(node->right.line) + "; C" + std::to_string(node->right.column) + "; O" + std::to_string(node->right.offset) + ") `" + std::string(contents.substr(node->right.offset, node->right.length).begin(), contents.substr(node->right.offset, node->right.length).end()) + "`");
    if (node->template_)
    {
        auto lines = create_string_tree(node->template_, contents);
        bool first = true;
        for (auto line : lines)
        {
            output.push_back((first ? std::string("- ") : std::string("  ")) + (first ? line + "\u001b[30;1m" " [template_]" "\u001b[0m" : line));
            first = false;
        }
    }
    return output;
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<attribute_arg_item_a> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<attribute_arg_item_b> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<attribute_args_a> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<attribute_args_b> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<attribute_item> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    switch (node->args.index())
    {
        case 0:
        if (std::get<std::shared_ptr<attribute_args_a>>(node->args))
        {
            auto lines = visit(std::get<std::shared_ptr<attribute_args_a>>(node->args));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<attribute_args_b>>(node->args))
        {
            auto lines = visit(std::get<std::shared_ptr<attribute_args_b>>(node->args));
        }
        break;
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<attribute> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->items)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->scope)
    {
        auto lines = visit(node->scope);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_method> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->return_type)
    {
        auto lines = visit(node->return_type);
    }
    if (node->arglist)
    {
        auto lines = visit(node->arglist);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_constructor> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->arglist)
    {
        auto lines = visit(node->arglist);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_indexer> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->arglist)
    {
        auto lines = visit(node->arglist);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_operator_binary_overload> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->left)
    {
        auto lines = visit(node->left);
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_operator_unary_overload> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_operator_nullar_overload> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->meta)
    {
        auto lines = visit(node->meta);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_property> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_field> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_method_arglist> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<contract_method_arglist_indexer> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<scope> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->body)
    {
        switch (element.index())
        {
            case 0:
            if (std::get<std::shared_ptr<control_structure>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<control_structure>>(element));
            }
            break;
            case 1:
            if (std::get<std::shared_ptr<statement>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<statement>>(element));
            }
            break;
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<scope_lambda> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->body)
    {
        switch (element.index())
        {
            case 0:
            if (std::get<std::shared_ptr<control_structure>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<control_structure>>(element));
            }
            break;
            case 1:
            if (std::get<std::shared_ptr<statement>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<statement>>(element));
            }
            break;
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<scope_getset> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->get)
    {
        auto lines = visit(node->get);
    }
    if (node->set)
    {
        auto lines = visit(node->set);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<control_structure_body> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->body.index())
    {
        case 0:
        if (std::get<std::shared_ptr<scope>>(node->body))
        {
            auto lines = visit(std::get<std::shared_ptr<scope>>(node->body));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<control_structure>>(node->body))
        {
            auto lines = visit(std::get<std::shared_ptr<control_structure>>(node->body));
        }
        break;
        case 2:
        if (std::get<std::shared_ptr<statement>>(node->body))
        {
            auto lines = visit(std::get<std::shared_ptr<statement>>(node->body));
        }
        break;
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<while_loop> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->condition)
    {
        auto lines = visit(node->condition);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<if_body> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->condition)
    {
        auto lines = visit(node->condition);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<else_body> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->else_body)
    {
        auto lines = visit(node->else_body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<for_body> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->pre)
    {
        auto lines = visit(node->pre);
    }
    if (node->condition)
    {
        auto lines = visit(node->condition);
    }
    if (node->post_inner)
    {
        auto lines = visit(node->post_inner);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<for_each_body> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->pre)
    {
        auto lines = visit(node->pre);
    }
    if (node->exp)
    {
        auto lines = visit(node->exp);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<if_else> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->if_)
    {
        auto lines = visit(node->if_);
    }
    if (node->else_)
    {
        auto lines = visit(node->else_);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<switch_case> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<switch_> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    for (auto element : node->part)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->default_body)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->pragmas)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<assembly_terminate> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<assembly> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->args)
    {
    }
    for (auto element : node->opcode)
    {
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<control_structure> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->pragmas)
    {
        auto lines = visit(node->pragmas);
    }
    switch (node->content.index())
    {
        case 0:
        if (std::get<std::shared_ptr<while_loop>>(node->content))
        {
            auto lines = visit(std::get<std::shared_ptr<while_loop>>(node->content));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<for_body>>(node->content))
        {
            auto lines = visit(std::get<std::shared_ptr<for_body>>(node->content));
        }
        break;
        case 2:
        if (std::get<std::shared_ptr<for_each_body>>(node->content))
        {
            auto lines = visit(std::get<std::shared_ptr<for_each_body>>(node->content));
        }
        break;
        case 3:
        if (std::get<std::shared_ptr<if_else>>(node->content))
        {
            auto lines = visit(std::get<std::shared_ptr<if_else>>(node->content));
        }
        break;
        case 4:
        if (std::get<std::shared_ptr<switch_>>(node->content))
        {
            auto lines = visit(std::get<std::shared_ptr<switch_>>(node->content));
        }
        break;
        case 5:
        if (std::get<std::shared_ptr<scope>>(node->content))
        {
            auto lines = visit(std::get<std::shared_ptr<scope>>(node->content));
        }
        break;
        case 6:
        if (std::get<std::shared_ptr<assembly>>(node->content))
        {
            auto lines = visit(std::get<std::shared_ptr<assembly>>(node->content));
        }
        break;
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_chain_start> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->part_alloc)
    {
        auto lines = visit(node->part_alloc);
    }
    if (node->part_free)
    {
        auto lines = visit(node->part_free);
    }
    if (node->part_call)
    {
        auto lines = visit(node->part_call);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_constant> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->typeof_)
    {
        auto lines = visit(node->typeof_);
    }
    if (node->nameof)
    {
        auto lines = visit(node->nameof);
    }
    if (node->sizeof_)
    {
        auto lines = visit(node->sizeof_);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_lambda> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->capture)
    {
        auto lines = visit(node->capture);
    }
    if (node->args)
    {
        auto lines = visit(node->args);
    }
    if (node->scope)
    {
        auto lines = visit(node->scope);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<capture_list_item> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<capture_list> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->items)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_value> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->exp_lambda)
    {
        auto lines = visit(node->exp_lambda);
    }
    if (node->exp_constant)
    {
        auto lines = visit(node->exp_constant);
    }
    if (node->scalar)
    {
        auto lines = visit(node->scalar);
    }
    if (node->integer_hex)
    {
        auto lines = visit(node->integer_hex);
    }
    if (node->integer_binary)
    {
        auto lines = visit(node->integer_binary);
    }
    if (node->integer)
    {
        auto lines = visit(node->integer);
    }
    if (node->character)
    {
        auto lines = visit(node->character);
    }
    if (node->string)
    {
        auto lines = visit(node->string);
    }
    if (node->constant)
    {
        auto lines = visit(node->constant);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_nullar> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->value.index())
    {
        case 0:
        if (std::get<std::shared_ptr<expression>>(node->value))
        {
            auto lines = visit(std::get<std::shared_ptr<expression>>(node->value));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_chain>>(node->value))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_chain>>(node->value));
        }
        break;
        case 2:
        if (std::get<std::shared_ptr<exp_value>>(node->value))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_value>>(node->value));
        }
        break;
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_unary> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->value.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_unary>>(node->value))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_unary>>(node->value));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_nullar>>(node->value))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_nullar>>(node->value));
        }
        break;
    }
    if (node->cast_target)
    {
        auto lines = visit(node->cast_target);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<expression> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->assign_to)
    {
        auto lines = visit(node->assign_to);
    }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    if (node->exp)
    {
        auto lines = visit(node->exp);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<encapsulation> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<namespace_> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->name)
    {
        auto lines = visit(node->name);
    }
    for (auto element : node->contracts)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->aliases)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->constants)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->namespaces)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->conversions)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->classes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->methods)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->properties)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->fields)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->pragmas)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<class_> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->scope)
    {
        auto lines = visit(node->scope);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->lifetime)
    {
        auto lines = visit(node->lifetime);
    }
    for (auto element : node->contracts)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->aliases)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->constants)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->indexers)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->operators_binary)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->operators_unary)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->operators_nullar)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->conversions)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->classes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->constructors)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->destructors)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->copystructors)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->properties)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->fields)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->methods)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->pragmas)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<method_arglist_item> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->type)
    {
        auto lines = visit(node->type);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<method_arglist> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<method_arglist_indexer> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<method_meta> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->encaps)
    {
        auto lines = visit(node->encaps);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<method> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->meta)
    {
        auto lines = visit(node->meta);
    }
    if (node->return_type)
    {
        auto lines = visit(node->return_type);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->arglist)
    {
        auto lines = visit(node->arglist);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<constructor> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->encaps)
    {
        auto lines = visit(node->encaps);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->arglist)
    {
        auto lines = visit(node->arglist);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<destructor> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->encaps)
    {
        auto lines = visit(node->encaps);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->arglist)
    {
        auto lines = visit(node->arglist);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<copystructor> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->encaps)
    {
        auto lines = visit(node->encaps);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->arglist)
    {
        auto lines = visit(node->arglist);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<conversion> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->meta)
    {
        auto lines = visit(node->meta);
    }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->source_type)
    {
        auto lines = visit(node->source_type);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<indexer> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->meta)
    {
        auto lines = visit(node->meta);
    }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->arglist)
    {
        auto lines = visit(node->arglist);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<operator_binary_overload> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->meta)
    {
        auto lines = visit(node->meta);
    }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->left)
    {
        auto lines = visit(node->left);
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<operator_unary_overload> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->meta)
    {
        auto lines = visit(node->meta);
    }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<operator_nullar_overload> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->meta)
    {
        auto lines = visit(node->meta);
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<property> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->meta)
    {
        auto lines = visit(node->meta);
    }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<field> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->attributes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    if (node->encaps)
    {
        auto lines = visit(node->encaps);
    }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<constant> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->target_type)
    {
        auto lines = visit(node->target_type);
    }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<using_> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->ident)
    {
        auto lines = visit(node->ident);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<alias_encapsulated> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->encaps)
    {
        auto lines = visit(node->encaps);
    }
    if (node->actual)
    {
        auto lines = visit(node->actual);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<alias> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->ident)
    {
        auto lines = visit(node->ident);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<call> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<call_body> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->args)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<free> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<alloc> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->type)
    {
        auto lines = visit(node->type);
    }
    if (node->exp)
    {
        auto lines = visit(node->exp);
    }
    if (node->body)
    {
        auto lines = visit(node->body);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<typeof_> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<nameof> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<sizeof_> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->type)
    {
        auto lines = visit(node->type);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<lifetime> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<type_match> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->base)
    {
        auto lines = visit(node->base);
    }
    if (node->lifetime)
    {
        auto lines = visit(node->lifetime);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<string_formatable> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->parts)
    {
        switch (element.index())
        {
            case 0:
            break;
            case 1:
            if (std::get<std::shared_ptr<expression>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<expression>>(element));
            }
            break;
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<string_literal> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->value.index())
    {
        case 0:
        if (std::get<std::shared_ptr<string_formatable>>(node->value))
        {
            auto lines = visit(std::get<std::shared_ptr<string_formatable>>(node->value));
        }
        break;
        case 1:
        break;
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<scalar_literal> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<integer_hex_literal> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<integer_binary_literal> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<integer_literal> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<char_literal> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<declaration> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->type)
    {
        auto lines = visit(node->type);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<return_statement> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->exp)
    {
        auto lines = visit(node->exp);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<statement> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->aliases)
    {
        auto lines = visit(node->aliases);
    }
    if (node->constants)
    {
        auto lines = visit(node->constants);
    }
    if (node->ret)
    {
        auto lines = visit(node->ret);
    }
    if (node->fwrd_decl)
    {
        auto lines = visit(node->fwrd_decl);
    }
    if (node->exp)
    {
        auto lines = visit(node->exp);
    }
    if (node->pragma)
    {
        auto lines = visit(node->pragma);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<pragma> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->contents)
    {
        switch (element.index())
        {
            case 0:
            if (std::get<std::shared_ptr<pragma_disable>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<pragma_disable>>(element));
            }
            break;
            case 1:
            if (std::get<std::shared_ptr<pragma_enable>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<pragma_enable>>(element));
            }
            break;
            case 2:
            if (std::get<std::shared_ptr<pragma_size>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<pragma_size>>(element));
            }
            break;
            case 3:
            if (std::get<std::shared_ptr<pragma_align>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<pragma_align>>(element));
            }
            break;
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<pragma_align> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<pragma_size> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<pragma_disable> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<pragma_enable> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<template_usage_item> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<template_usage> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->items)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<template_definition_item_direct_type> node)
{
    if (!visit_enter(node)) { return false; }
    if (node->value)
    {
        auto lines = visit(node->value);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<template_definition_item_identifier> node)
{
    if (!visit_enter(node)) { return false; }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<template_definition> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->items)
    {
        switch (element.index())
        {
            case 0:
            if (std::get<std::shared_ptr<template_definition_item_identifier>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<template_definition_item_identifier>>(element));
            }
            break;
            case 1:
            if (std::get<std::shared_ptr<template_definition_item_direct_type>>(element))
            {
                auto lines = visit(std::get<std::shared_ptr<template_definition_item_direct_type>>(element));
            }
            break;
        }
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_chain> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_chain>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_chain>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_chain_start>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_chain_start>>(node->left));
        }
        break;
    }
    if (node->chain_call)
    {
        auto lines = visit(node->chain_call);
    }
    if (node->indirection_call)
    {
        auto lines = visit(node->indirection_call);
    }
    if (node->chain_indexer)
    {
        auto lines = visit(node->chain_indexer);
    }
    if (node->chain_template)
    {
        auto lines = visit(node->chain_template);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_binary_4> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_binary_4>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_binary_4>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_unary>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_unary>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_binary_3> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_binary_3>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_binary_3>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_binary_4>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_binary_4>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_binary_2> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_binary_2>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_binary_2>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_binary_3>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_binary_3>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_binary_1> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_binary_1>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_binary_1>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_binary_2>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_binary_2>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_arithmetic_2> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_arithmetic_2>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_arithmetic_2>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_binary_1>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_binary_1>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_arithmetic_1> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_arithmetic_1>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_arithmetic_1>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_arithmetic_2>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_arithmetic_2>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_compare> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_compare>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_compare>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_arithmetic_1>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_arithmetic_1>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_equality> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_equality>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_equality>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_compare>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_compare>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_and> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_and>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_and>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_equality>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_equality>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<exp_or> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<exp_or>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_or>>(node->left));
        }
        break;
        case 1:
        if (std::get<std::shared_ptr<exp_and>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<exp_and>>(node->left));
        }
        break;
    }
    if (node->right)
    {
        auto lines = visit(node->right);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<ident_navigation> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<ident_navigation>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<ident_navigation>>(node->left));
        }
        break;
        case 1:
        break;
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<type_navigation> node)
{
    if (!visit_enter(node)) { return false; }
    switch (node->left.index())
    {
        case 0:
        if (std::get<std::shared_ptr<type_navigation>>(node->left))
        {
            auto lines = visit(std::get<std::shared_ptr<type_navigation>>(node->left));
        }
        break;
        case 1:
        break;
    }
    if (node->template_)
    {
        auto lines = visit(node->template_);
    }
    return visit_leave(node);
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<attribute_arg_item_a> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<attribute_arg_item_b> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<attribute_args_a> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<attribute_args_b> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<attribute_item> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<attribute> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_method> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_constructor> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_indexer> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_operator_binary_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_operator_unary_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_operator_nullar_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_property> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_field> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_method_arglist> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<contract_method_arglist_indexer> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<scope> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<scope_lambda> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<scope_getset> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<control_structure_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<while_loop> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<if_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<else_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<for_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<for_each_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<if_else> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<switch_case> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<switch_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<assembly_terminate> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<assembly> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<control_structure> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_chain_start> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_constant> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_lambda> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<capture_list_item> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<capture_list> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_value> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_nullar> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_unary> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<expression> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<encapsulation> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<namespace_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<class_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<method_arglist_item> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<method_arglist> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<method_arglist_indexer> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<method_meta> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<method> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<constructor> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<destructor> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<copystructor> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<conversion> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<indexer> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<operator_binary_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<operator_unary_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<operator_nullar_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<property> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<field> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<constant> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<using_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<alias_encapsulated> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<alias> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<call> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<call_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<free> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<alloc> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<typeof_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<nameof> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<sizeof_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<lifetime> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<type_match> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<string_formatable> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<string_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<scalar_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<integer_hex_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<integer_binary_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<integer_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<char_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<declaration> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<return_statement> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<statement> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<pragma> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<pragma_align> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<pragma_size> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<pragma_disable> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<pragma_enable> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<template_usage_item> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<template_usage> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<template_definition_item_direct_type> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<template_definition_item_identifier> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<template_definition> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<main> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_chain> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_binary_4> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_binary_3> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_binary_2> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_binary_1> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_arithmetic_2> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_arithmetic_1> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_compare> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_equality> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_and> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<exp_or> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<ident_navigation> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_enter(std::shared_ptr<type_navigation> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<attribute_arg_item_a> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<attribute_arg_item_b> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<attribute_args_a> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<attribute_args_b> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<attribute_item> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<attribute> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_method> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_constructor> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_indexer> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_operator_binary_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_operator_unary_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_operator_nullar_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_property> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_field> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_method_arglist> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<contract_method_arglist_indexer> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<scope> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<scope_lambda> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<scope_getset> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<control_structure_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<while_loop> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<if_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<else_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<for_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<for_each_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<if_else> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<switch_case> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<switch_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<assembly_terminate> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<assembly> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<control_structure> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_chain_start> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_constant> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_lambda> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<capture_list_item> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<capture_list> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_value> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_nullar> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_unary> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<expression> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<encapsulation> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<namespace_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<class_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<method_arglist_item> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<method_arglist> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<method_arglist_indexer> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<method_meta> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<method> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<constructor> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<destructor> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<copystructor> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<conversion> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<indexer> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<operator_binary_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<operator_unary_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<operator_nullar_overload> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<property> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<field> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<constant> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<using_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<alias_encapsulated> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<alias> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<call> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<call_body> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<free> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<alloc> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<typeof_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<nameof> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<sizeof_> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<lifetime> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<type_match> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<string_formatable> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<string_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<scalar_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<integer_hex_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<integer_binary_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<integer_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<char_literal> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<declaration> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<return_statement> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<statement> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<pragma> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<pragma_align> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<pragma_size> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<pragma_disable> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<pragma_enable> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<template_usage_item> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<template_usage> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<template_definition_item_direct_type> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<template_definition_item_identifier> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<template_definition> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<main> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_chain> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_binary_4> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_binary_3> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_binary_2> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_binary_1> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_arithmetic_2> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_arithmetic_1> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_compare> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_equality> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_and> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<exp_or> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<ident_navigation> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit_leave(std::shared_ptr<type_navigation> node)
{
    return true;
}
bool leaf::parsing::instance::visitor::visit(std::shared_ptr<main> node)
{
    if (!visit_enter(node)) { return false; }
    for (auto element : node->usings)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->contract)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->aliases)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->namespaces)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->conversions)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->classes)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->methods)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->properties)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->fields)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    for (auto element : node->pragmas)
    {
        if (element)
        {
            auto lines = visit(element);
        }
    }
    return visit_leave(node);
}
